
@startuml 1.txç¼–è§£ç ç±»å›¾
    title
        Txç¼–è§£ç ç±»å›¾
    end title

    'left to right direction

    namespace CosmosSDK {
        namespace baseapp {
            struct BaseApp {
                sdk.TxDecoder txDecoder
            }
            note left of BaseApp::txDecoder
                äº¤æ˜“è§£ç å‡½æ•°æŒ‡é’ˆï¼Œå‡½æ•°åŸå‹ä¸ºï¼š
                type TxDecoder func(txBytes []byte) (Tx, error)
                å­—æ®µåˆå§‹åŒ–ï¼š
                txDecoder = encodingConfig.TxConfig.TxDecoder()
            end note
        }
        namespace codec.types {
            interface AnyUnpacker #LimeGreen {
                UnpackAny(interface{}) error
            }
            note top of AnyUnpacker
                è¿™ä¸ªæ¥å£æ˜¯ interfaceRegistry ç»“æ„
                ä½¿ç”¨åœ¨å®ƒé‡Œé¢æ³¨å†Œçš„æ¨¡å—è§£ç ä»»æ„æ¶ˆæ¯çš„å…³é”®ç‚¹ã€‚
                ----
                ç¼–ç åçš„æ¶ˆæ¯ä¸­æœ‰å…¶æ‰€å±æ¨¡å—çš„ç±»å‹URLï¼Œ
                é€šè¿‡ç±»å‹URLå¯ä»¥æ‰¾åˆ°å¯¹åº”çš„æ¨¡å—ï¼Œ
            end note 

            interface InterfaceRegistry #SkyBlue {

            }
            AnyUnpacker <|- InterfaceRegistry

            struct interfaceRegistry {
                map[string]reflect.Type interfaceNames
                ....
                map[reflect.Type]interfaceMap interfaceImpls
                ....
                map[string]reflect.Type typeURLMap
            }
            InterfaceRegistry <|-- interfaceRegistry
        }

        namespace client {
            interface TxEncodingConfig {
                <b><color:blue>func</color></b> TxEncoder
                ....
                <b><color:blue>func</color></b> TxDecoder
                ....
                <b><color:blue>func</color></b> TxJSONEncoder
                ....
                <b><color:blue>func</color></b> TxJSONDecoder
            }

            interface TxConfig #SkyBlue {

            }
            TxEncodingConfig <|-- TxConfig
        }
        namespace x.auth.tx {
            struct config {
                signing.SignModeHandler handler
                ....
                sdk.TxDecoder decoder
                ....
                sdk.TxEncoder encoder
                ....
                sdk.TxDecoder jsonDecoder
                ....
                sdk.TxEncoder jsonEncoder
                ....
                codec.ProtoCodecMarshaler protoCodec
            }
            entity DefaultTxDecoder as "<b><color:blue>func</color></b> DefaultTxDecoder" {
                // è¿”å›ä¸€ä¸ªé—­åŒ…å‡½æ•°ä½œä¸º txDecoder
            }
            entity DefaultTxEncoder as "<b><color:blue>func</color></b> DefaultTxEncoder"

            config::decoder -> DefaultTxDecoder
            config::encoder --> DefaultTxEncoder
        }
        client.TxConfig <|-- x.auth.tx.config

        namespace codec {
            interface BinaryCodec {

            }
            interface JSONCodec {

            }

            interface Codec #SkyBlue {

            }
            BinaryCodec <|-- Codec
            JSONCodec <|-- Codec

            interface ProtoCodecMarshaler {

            }
            Codec <|-- ProtoCodecMarshaler

            interface ProtoMarshaler {
                //æ¯ä¸ªprotoæ¶ˆæ¯éƒ½è¦å®ç°è¯¥æ¥å£
            }
            struct ProtoCodec {
                types.InterfaceRegistry interfaceRegistry
            }
            note left of ProtoCodec
                //ProtoCodecçš„Unmarshalå‡½æ•°å®ç°ï¼š
                <code>
                Unmarshal(bz []byte, ptr ProtoMarshaler){
                    ptr.Unmarshal(bz) // 
                    types.UnpackInterfaces(ptr, pc.interfaceRegistry)
                }
                </code>
            end note
            ProtoCodecMarshaler <|-- ProtoCodec
            ProtoCodec ..> ProtoMarshaler

            struct LegacyAmino #SkyBlue {

            }
        }

        namespace simapp.params {
            struct EncodingConfig #SkyBlue {
                types.InterfaceRegistry InterfaceRegistry
                ....
                codec.Codec Codec
                ....
                client.TxConfig TxConfig
                ....
                codec.LegacyAmino Amino
            }

        }
        simapp.params.EncodingConfig::InterfaceRegistry o--> codec.types.interfaceRegistry
        simapp.params.EncodingConfig::TxConfig o--> x.auth.tx.config
        simapp.params.EncodingConfig::Codec o---> codec.ProtoCodec 
        simapp.params.EncodingConfig::Amino o--> codec.LegacyAmino

        codec.ProtoCodec::interfaceRegistry o--> codec.types.interfaceRegistry

        baseapp.BaseApp::txDecoder .[#DarkGreen].> client.TxEncodingConfig::TxDecoder 
    
        'txDecoderçš„å‚æ•°
        x.auth.tx.DefaultTxDecoder ..[#Blue]..> codec.ProtoCodec : ProtoCodec å°±æ˜¯ txDecoder çš„å‚æ•° cdc

    }

    namespace Ethermint {
        namespace app {
            struct EthermintApp {

            }

            CosmosSDK.baseapp.BaseApp <|--- EthermintApp : åµŒå…¥BaseAppå®ç°ç»§æ‰¿
        }



    }


@enduml


@startuml 2.txDecoderå­—æ®µçš„åˆå§‹åŒ–
    title
        txDecoderå­—æ®µçš„åˆå§‹åŒ–
    end title

    box Ethermint
        participant main as "ğŸ“¦ï¸<<package>> \n main \n åœ¨ cmd/ethermintd ç›®å½•"
        participant app as "ğŸ“¦ï¸<<package>> \n app"
        participant encoding as "ğŸ“¦ï¸<<package>> \n encoding"
        participant enccodec as "ğŸ“¦ï¸<<package>> \n encoding.codec"
        participant ethermintCryptoCodec as "ğŸ“¦ï¸<<package>> \n crypto.codec"
        participant ethermintTypes as "ğŸ“¦ï¸<<package>> \n types"
    end box

    box CosmosSDK #SkyBlue
        participant baseapp as "ğŸ“¦ï¸<<package>> \n baseapp"
        participant std as "ğŸ“¦ï¸<<package>> \n std"
        participant sdk as "ğŸ“¦ï¸<<package>> \n types"
        participant typesTx as "ğŸ“¦ï¸<<package>> \n types.tx"
        participant cryptocodec as "ğŸ“¦ï¸<<package>> \n crypto.codec"
        participant BasicManager as "ğŸš§<<struct>> \n types.module.BasicManager"
        participant interfaceRegistry as "ğŸš§<<struct>> \n codec.types.interfaceRegistry"
    end box

    autonumber
    autoactivate on
    
    -> main : main()

        main -> main #DodgerBlue :  NewRootCmd()

            main -> encoding : encodingConfig = encoding.MakeConfig(mb)
                note over encoding 
                    å‚æ•°mbçš„å–å€¼ï¼š mb = app.ModuleBasics
                    ----
                    app.ModuleBasics çš„ç±»å‹ä¸ºï¼š
                    type BasicManager map[string]AppModuleBasic
                    å®ƒåœ¨å®šä¹‰æ—¶å³åˆå§‹åŒ–ï¼›
                    ----
                    <b><color:red>å®ƒç®¡ç†æ‰€æœ‰æ¨¡å—çš„ AppModuleBasic æ¥å£å®ä¾‹</color></b>
                end note 

                note over encoding 
                    //<color:DarkGreen> amino = CosmosSDK.codec
                    //<color:DarkGreen> tx = CosmosSDK.x.auth.tx
                    //<color:DarkGreen> types = CosmosSDK.codec.types
                    encodingConfig.InterfaceRegistry = types.NewInterfaceRegistry()
                    encodingConfig.Codec = amino.NewProtoCodec(encodingConfig.InterfaceRegistry)
                    encodingConfig.TxConfig = tx.NewTxConfig(encodingConfig.Codec, tx.DefaultSignModes)
                    encodingConfig.Amino = amino.NewLegacyAmino()
                end note 

                encoding -> enccodec : enccodec.RegisterLegacyAminoCodec()ï¼Œ å‚æ•°ï¼š\
                \n cdc = encodingConfig.Amino
                return 

                encoding -> BasicManager : mb.RegisterLegacyAminoCodec() ï¼Œ å‚æ•°ï¼š\
                \n cdc = encodingConfig.Amino
                return
                note over encoding #LightPink
                    interfaceRegistry åœ¨è¿™é‡ŒæŒ‡å‘ codec.types.interfaceRegistry
                    ----
                    <code>
                    type interfaceRegistry struct {
                        interfaceNames map[string]reflect.Type // protoName -> reflect.Type
                        interfaceImpls map[reflect.Type]interfaceMap // reflect.Type -> map(typeURL, reflect.Type)
                        typeURLMap     map[string]reflect.Type // typeURL -> reflect.Type
                    }
                    </code>
                end note
                encoding -> enccodec : enccodec.RegisterInterfaces()ï¼Œ å‚æ•°ï¼š\
                \n interfaceRegistry = encodingConfig.InterfaceRegistry
                    group #LightPink "std.RegisterInterfaces(interfaceRegistry)çš„è¯¦ç»†è¯´æ˜ï¼› ä¸‹é¢çš„ä¸¤ä¸ªè°ƒç”¨æ˜¯ç±»ä¼¼çš„ï¼Œ éƒ½æ˜¯å¡«å…… struct interfaceRegistry çš„å­—æ®µ"
                        enccodec -> std : std.RegisterInterfaces(interfaceRegistry)
                            std -> sdk : sdk.RegisterInterfaces(interfaceRegistry) \
                            \n sdk å³ cosmos-sdkçš„ package types 
                                sdk -> interfaceRegistry : registry.RegisterInterface(MsgInterfaceProtoName, (*Msg)(nil))
                                    note over interfaceRegistry
                                        å®å‚ï¼š
                                        MsgInterfaceProtoName = "cosmos.base.v1beta1.Msg"
                                        ----
                                        RegisterInterface çš„å®ç°ï¼š
                                        type = reflect.TypeOf(iface) // é€šè¿‡åå°„å¾—åˆ° Msg æ¥å£çš„ç±»å‹
                                        registry.interfaceNames[protoName] = typ // è®°å½•æ˜ å°„å…³ç³»
                                    end note 
                                return
                            return
                            
                            std -> typesTx : txtypes.RegisterInterfaces(interfaceRegistry)
                                typesTx -> interfaceRegistry : å¤šæ¬¡æ³¨å†Œ
                                note over typesTx, interfaceRegistry
                                    <code>
                                    // msgResponseInterfaceProtoName = "cosmos.tx.v1beta1.MsgResponse"
                                    registry.RegisterInterface(msgResponseInterfaceProtoName, (*MsgResponse)(nil))
                                    registry.RegisterInterface("cosmos.tx.v1beta1.Tx", (*sdk.Tx)(nil))
                                    registry.RegisterImplementations((*sdk.Tx)(nil), &Tx{})
                                    registry.RegisterInterface("cosmos.tx.v1beta1.TxExtensionOptionI", (*TxExtensionOptionI)(nil))
                                    </code>
                                end note 
                                note over interfaceRegistry
                                    RegisterImplementations çš„å®ç°ï¼š
                                    ----
                                    for impl in impls 
                                        typeURL := "/" + proto.MessageName(impl) //å–å‡ºæ¶ˆæ¯åï¼Œåˆæˆ typeURL 
                                        //å°† typeURL -> implå¯¹åº”çš„typeåŠ å…¥æ˜ å°„
                                        implType = reflect.TypeOf(impl)
                                        imap = registry.interfaceImpls[ityp]
                                        imap[typeURL] = implType
                                        registry.typeURLMap[typeURL] = implType
                                        registry.interfaceImpls[ityp] = imap
                                end note 
                                return
                            return

                            std -> cryptocodec : cryptocodec.RegisterInterfaces(interfaceRegistry)
                                cryptocodec -> interfaceRegistry : å¤šæ¬¡æ³¨å†Œ
                                    note over cryptocodec, interfaceRegistry
                                        <code>
                                        var pk *cryptotypes.PubKey
                                        registry.RegisterInterface("cosmos.crypto.PubKey", pk)
                                        registry.RegisterImplementations(pk, &ed25519.PubKey{})
                                        registry.RegisterImplementations(pk, &secp256k1.PubKey{})
                                        registry.RegisterImplementations(pk, &multisig.LegacyAminoPubKey{})

                                        var priv *cryptotypes.PrivKey
                                        registry.RegisterInterface("cosmos.crypto.PrivKey", priv)
                                        registry.RegisterImplementations(priv, &secp256k1.PrivKey{})
                                        registry.RegisterImplementations(priv, &ed25519.PrivKey{}) //nolint
                                        secp256r1.RegisterInterfaces(registry)
                                        </code>
                                    end note 
                                return
                            return
                        end group
                        enccodec -> ethermintCryptoCodec :cryptocodec.RegisterInterfaces(interfaceRegistry)
                        return
                        enccodec -> ethermintTypes : ethermint.RegisterInterfaces(interfaceRegistry)
                        return
                    return
                return 

                encoding -> BasicManager : mb.RegisterInterfaces(encodingConfig.InterfaceRegistry) 
                    note over BasicManager #LightPink 
                        <code>
                        // è¿™ä¼šéå†æ‰€æœ‰å®šä¹‰åœ¨ app ä¸­çš„æ¨¡å—
                        for _, m := range bm {
                            m.RegisterInterfaces(registry)
                        }
                        </code>
                        ----
                        ä»¥ EVM æ¨¡å—çš„ RegisterInterfaces ä¸ºä¾‹ï¼š
                        * ä¸º CosmosSDK.types.tx.TxExtensionOptionI æ³¨å†Œå®ç° ExtensionOptionsEthereumTx
                        * ä¸º CosmosSDK.types.Msg æ³¨å†Œå®ç° MsgEthereumTx
                        * æ³¨å†Œæ¥å£ "ethermint.evm.v1.TxData" -> TxData, å¹¶æ³¨å†Œå®ç° AccessListTxï¼Œ LegacyTxï¼Œ DynamicFeeTx
                    end note 
                return

            return : appCreator.encCfg = encodingConfig
            note over main
                è®¾ç½®ç¯å¢ƒï¼Œ æœ‰è®¸å¤šæ“ä½œç•¥è¿‡
                appCreator.newApp() ä¸º start å‘½ä»¤çš„å›è°ƒæ‰§è¡Œå‡½æ•°
                ----
                type appCreator struct {
                    encCfg params.EncodingConfig
                }
            end note 
            main -> main : appCreator.newApp()

                main -> app: app.NewEthermintApp(), å‚æ•°ï¼š\
                \n encodingConfig = appCreator.encCfg

                    app -> baseapp : baseapp.NewBaseApp()ï¼Œ å‚æ•°ï¼š\
                    \n txDecoder = encodingConfig.TxConfig.TxDecoder()
                        note over baseapp
                            encodingConfig.TxConfig.TxDecoder() 
                            å‡½æ•°çš„æ‰§è¡Œåï¼Œè¿”å› txDecoder
                            ----
                            encodingConfigçš„ç±»å‹ä¸ºï¼š
                            simappparams.EncodingConfig
                        end note 
                    return

                return

            return 

        return




    return


@enduml


@startuml 3.txçš„ç»“æ„
    title
        txçš„ç»“æ„
        ç¼–ç  å’Œ è§£ç  ç›¸å…³çš„æ•°æ®ç»“æ„
        ç¼–ç éƒ¨åˆ†ä»¥ MsgEthereumTx çš„ç¼–ç ä¸ºä¾‹
    end title

    namespace CosmosSDK {

        namespace client {

            struct Context {
                TxConfig TxConfig
            }

            interface TxEncodingConfig {
                TxEncoder() sdk.TxEncoder
                ....
                TxDecoder() sdk.TxDecoder
                ....
                TxJSONEncoder() sdk.TxEncoder
                ....
                TxJSONDecoder() sdk.TxDecoder
            }

            interface TxConfig {
                NewTxBuilder() TxBuilder
                ....
                WrapTxBuilder(sdk.Tx) (TxBuilder, error)
            }
            TxEncodingConfig <|-- TxConfig
            Context o--> TxConfig

            interface TxBuilder {
                GetTx() signing.Tx
                ....
                SetMsgs(msgs ...sdk.Msg) error
            }
            TxConfig --> TxBuilder : å¼•ç”¨

        }

        namespace codec.types {
            interface UnpackInterfacesMessage {
                UnpackInterfaces(unpacker AnyUnpacker) error
            }

            interface AnyUnpacker {
                UnpackAny(any *Any, iface interface{}) error
            }
            UnpackInterfacesMessage ..> AnyUnpacker

            struct Any #SpringGreen {
                string TypeUrl; // è®°å½•å®é™…ç±»å‹çš„URL;ä¾‹å¦‚å–å€¼ä¸º '/cosmos.bank.v1beta1.MsgSend'
                ....
                []byte Value; //ç¼–ç åçš„æ•°æ®
                ....
                cachedValue interface{}; //å­˜æ”¾è§£ç åçš„å®é™…ç±»å‹
            }

            AnyUnpacker ..> Any
        }

        namespace types {
            interface Message <<å®šä¹‰åœ¨protobufä¸­>> {
                Reset()
                ....
                String() string
                ....
                ProtoMessage()
            }

            interface Msg {
                ValidateBasic() error
                ....
                GetSigners() []AccAddress
            }
            Message <|-- Msg :åµŒå…¥æ¥å£

            collections AllModuleMsgs [
                =å„ä¸ªæ¨¡å—çš„æ¶ˆæ¯
            ]
            Msg <|-[thickness=3]- AllModuleMsgs

            interface Tx #LimeGreen {
                GetMsgs() []Msg
                ....
                ValidateBasic() error
            }
            Tx -> Msg 
            interface FeeTx {
            }
            Tx <|-- FeeTx

            namespace tx {
                interface TipTx {
                }

                struct TxBody {
                    []codec.types.Any Messages
                    ....
                    string Memo
                    ....
                    uint64 TimeoutHeight
                    ....
                    []codec.types.Any ExtensionOptions
                    ....
                    []codec.types.Any NonCriticalExtensionOptions
                }

                struct AuthInfo {
                    []SignerInfo SignerInfos; // struct SignerInfo
                    ....
                    Fee Fee; // struct Fee
                    ....
                    Tip Tip; // struct Tip
                }

                struct Tx <<types/tx/tx.pb.go>> #SkyBlue {
                    TxBody Body
                    ....
                    AuthInfo AuthInfo
                    ....
                    [][]byte Signatures
                }
                Tx o--> TxBody
                Tx o--> AuthInfo

                note as pbTxNote
                    <code>
                    func (t *Tx) GetMsgs() []sdk.Msg { 
                        ...
                        anys := t.Body.Messages

                        //å°† Any ç»“æ„ä½“ä¸­çš„ cachedValue å­—æ®µ
                        //å¼ºåˆ¶ç±»å‹è½¬æ¢ä¸º sdk.Msg
                        res, err := GetMsgs(anys, "transaction")
                        return res
                    }
                    </code>
                end note 
                Tx --> pbTxNote


                struct TxRaw <<types/tx/tx.pb.go>> {
                    BodyBytes []byte
                    ....
                    AuthInfoBytes []byte
                    ....
                    Signatures [][]byte
                }
                Tx -> TxRaw : ç›¸å…³è”
            }
            FeeTx <|-- tx.TipTx
            Tx <|-- tx.Tx
        }

        codec.types.Any ---o types.tx.TxBody
        codec.types.UnpackInterfacesMessage <|---- types.tx.TxBody
        codec.types.UnpackInterfacesMessage <|---- types.tx.AuthInfo
        

        namespace x.auth {
            namespace tx {
                interface ExtensionOptionsTxBuilder {
                }

                struct config {
                    decoder     sdk.TxDecoder
                    ....
                    encoder     sdk.TxEncoder
                    ....
                    protoCodec  codec.ProtoCodecMarshaler
                }

                struct wrapper #SkyBlue {
                    cdc codec.Codec
                    ....
                    tx *tx.Tx
                    ....
                    bodyBz []byte
                    ....
                    authInfoBz []byte
                }
                note bottom of wrapper
                    =å®ç°çš„Txæ¥å£å‡½æ•°
                    ....
                    <code>
                    func (w *wrapper) GetMsgs() []sdk.Msg {
                        return w.tx.GetMsgs()
                    }
                    </code>
                    ====
                    =å®ç°çš„TxBuilderæ¥å£å‡½æ•°
                    ....
                    <code>
                    func (w *wrapper) SetMsgs(msgs ...sdk.Msg) error {
                        anys, err := tx.SetMsgs(msgs)
                        w.tx.Body.Messages = anys
                        w.bodyBz = nil
                    }
                    </code>
                    ....
                    <code>
                    //è¿”å›è‡ªå·±ï¼Œå› ä¸ºå®ƒè‡ªå·±å°±å®ç°äº† Tx æ¥å£
                    func (w *wrapper) GetTx() authsigning.Tx {
                        return w
                    }
                    </code>
                end note
                ExtensionOptionsTxBuilder <|-- wrapper

                config --> wrapper : configåˆ›å»ºçš„TxBuilderå°±æ˜¯wrapper


            }

            namespace signing {
                collections ManyTxInf [
                    =å¤šç§Txæ¥å£ï¼Œç®€ç›´é›†é½äº†
                    ----
                    * SigVerifiableTx
                    * types.Tx
                    * types.TxWithMemo
                    * types.FeeTx
                    * types.tx.TipTx
                    * types.TxWithTimeoutHeight
                ]

                interface Tx 

                ManyTxInf <|-[thickness=3]- Tx
            }
            signing.Tx <|-- tx.wrapper

            ' namespace ante {
            '     interface HasExtensionOptionsTx {

            '     }
            ' }
            ' ante.HasExtensionOptionsTx <|-- tx.wrapper
        }
        client.TxConfig <|--- x.auth.tx.config
        client.TxBuilder <|-- x.auth.tx.ExtensionOptionsTxBuilder

        types.tx.TipTx <|-[#Red]-- x.auth.tx.wrapper

        x.auth.tx.wrapper o-up[#Blue,thickness=2]--> types.tx.Tx : <color:Blue>txå­—æ®µ
    }


@enduml

@startuml 4.messageçš„ç¼–ç æµç¨‹
    title
        messageçš„ç¼–ç æµç¨‹
        ä»¥ MsgEthereumTx ä¸ºä¾‹
    end title

    box Ethermint
        participant "<struct>ğŸš§ \n package rpc/backend \n Backend " as Backend

        participant "<package>ğŸ“¦ï¸ \n package x/evm/types" as xEvmTypes

        participant "<struct>ğŸš§ \n package x/evm/types \n MsgEthereumTx " as MsgEthereumTx


    end box

    box CosmosSDK
        participant "<package>ğŸ“¦ï¸ \n package codec/types" as codecTypes
    end box

    autonumber
    autoactivate on


    -> Backend : SendRawTransaction(data hexutil.Bytes)
        note over Backend
            // è¿™æ˜¯ go-ethereum ä¸­çš„ç±»å‹
            tx := &ethtypes.Transaction{}
            ----
            æ„é€  ethereum ä¸­çš„ç±»å‹å¯¹ Tx è¿›è¡Œæ ¡éªŒ
        end note 

        note over Backend
            å…ˆæ„é€ ä¸€ä¸ªå¯¹è±¡ï¼Œå†å¡«å……å­—æ®µ
            ethereumTx := &evmtypes.MsgEthereumTx{}
        end note 
        Backend -> MsgEthereumTx : ethereumTx.FromEthereumTx(tx)
            MsgEthereumTx -> xEvmTypes : NewTxDataFromTx(tx)
                note over xEvmTypes
                    åœ¨ NewTxDataFromTx å‡½æ•°ä¸­ï¼š
                    ----
                    <code>
                    switch tx.Type() {
                    case ethtypes.DynamicFeeTxType:
                        txData, err = newDynamicFeeTx(tx)
                    case ethtypes.AccessListTxType:
                        txData, err = newAccessListTx(tx)
                    default:
                        txData, err = newLegacyTx(tx)
                    }
                    </code>
                end note 
            return :txData : TxData

            MsgEthereumTx -> xEvmTypes : PackTxData(txData)
                note over xEvmTypes
                    å°† txData å¼ºè½¬ä¸º  proto.Message ç±»å‹ï¼š
                    msg, ok := txData.(proto.Message)
                    ----
                    <img:../plantuml-img/plantumls/102.txç¼–è§£ç /5.Evmæ¨¡å—çš„TxData.svg>
                end note
            return : anyTxData : codectypes.Any

            MsgEthereumTx -> codecTypes : codecTypes.NewAnyWithValue(anyTxData)
                note over codecTypes #LightPink
                    <code>
                    // v å°±æ˜¯ anyTxData
                    bz, err := proto.Marshal(v)
                    // æ„é€  Any ç»“æ„ä½“å¹¶è¿”å›
                    return &Any{
                        TypeUrl:     "/" + proto.MessageName(v),
                        Value:       bz,
                        cachedValue: v,
                    }, nil
                    </code>
                end note
            return
        return
    return

@enduml


@startuml 5.Evmæ¨¡å—çš„TxData
    title
        Evmæ¨¡å—çš„TxData
    end title

    namespace Ethermint {
        namespace x.evm {
            namespace types {
                interface TxData {

                }
                note right of TxData
                    TxData è™½ç„¶æ²¡æœ‰å®ç° proto.Message æ¥å£ï¼Œ
                    ä½†æ˜¯å®ƒçš„å®ç°ç±» AccessListTxï¼Œ LegacyTxï¼Œ 
                    DynamicFeeTx éƒ½å®ç°äº†ï¼›
                    ----
                    å› æ­¤ï¼ŒTxData ä¹Ÿå¯ä»¥çœ‹ä½œæ˜¯ proto.Message
                end note 

                struct LegacyTx {

                }
                struct AccessListTx {

                }
                struct DynamicFeeTx {

                }

                TxData <|-- LegacyTx
                TxData <|-- AccessListTx
                TxData <|-- DynamicFeeTx

                interface "proto.Message" as Message <<å®šä¹‰åœ¨protobufä¸­>> {
                    Reset()
                    ....
                    String() string
                    ....
                    ProtoMessage()
                }
                Message <|-[#Blue]- LegacyTx
                Message <|-[#Blue]- AccessListTx
                Message <|-[#Blue]- DynamicFeeTx
            }
        }
    }
@enduml