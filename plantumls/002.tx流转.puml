@startuml 1.txçš„æµè½¬æµç¨‹
    title
        txçš„æµè½¬æµç¨‹
    end title
    
    
    actor cli

    box Tendermint
        participant rpcServer as "<<åœ¨node.Node.startRPCä¸­æ³¨å†Œ>> \n rpc.core.Routesä¸­ \n æ³¨å†Œçš„æ¶ˆæ¯å¤„ç†å‡½æ•°"


        participant rpcClientLocal as "ğŸš§<<struct>> \n rpc.client.local.Local"
        participant rpcCore as "ğŸ“¦ï¸<<package>> \n rpc.core"

        participant CListMempool as "ğŸš§<<struct>> \n mempool.v0.CListMempool"
        participant appConnMempool as "ğŸš§<<struct>> \n proxy.appConnMempool"
        participant localClient as "ğŸš§<<struct>> \n abci.abcicli.localClient"
    end box

    box CosmosSDK
        participant clientContext as "ğŸ“¦ï¸<<package>> \n client.Context"
        participant baseapp as "ğŸš§<<struct>> \n baseapp.BaseApp"
    end box

    box ethermint
        participant PublicAPI as "ğŸš§<<struct>> \n rpc.namespaces.ethereum.eth.PublicAPI"
        participant rpcBackend as "ğŸš§<<struct>> \n rpc.backend.Backend"
    end box

    autonumber
    autoactivate on

    ==ethermint çš„å®é™…å…¥å£==

    
    cli -> PublicAPI : [ğŸ“¨msg]PublicAPI.SendRawTransaction(data) \
    \n data æ˜¯ eth_sendRawTransaction ä¼ é€’çš„æ•°æ®
        PublicAPI -> rpcBackend : e.backend.SendRawTransaction(data) \
        \n e å°±æ˜¯ PublicAPI ç»“æ„ä½“ 
        
            note over rpcBackend
                tx.UnmarshalBinary(data)
                å°†æ•°æ®è§£ç ä¸ºä»¥å¤ªåŠçš„ tx
                ----
                å¯¹ tx è¿›è¡Œæ ¡éªŒ
            end note
            note over rpcBackend
                ethereumTx := &evmtypes.MsgEthereumTx{}
                ethereumTx.FromEthereumTx(tx)
                cosmosTx := ethereumTx.BuildTx(...)
                txBytes := b.clientCtx.TxConfig.TxEncoder()(cosmosTx) // b å°±æ˜¯ Backend
                ----
                æ„é€  cosmos çš„ evm æ¨¡å— message
            end note 
            note over rpcBackend #SkyBlue
                // ä» evm æ ¼å¼çš„äº‹åŠ¡ä¸­è®¡ç®—å‡º txHash
                txHash := ethereumTx.AsTransaction().Hash()
            end note

            note over rpcBackend
                syncCtx := b.clientCtx.WithBroadcastMode(flags.BroadcastSync)
            end note 

            rpcBackend -> clientContext : syncCtx.BroadcastTx(txBytes) 
                clientContext -> clientContext : ctx.BroadcastTxSync(txBytes)
                    note over clientContext
                        node := ctx.GetNode()
                    end note 
                    clientContext -> rpcClientLocal : node.BroadcastTxSync(context.Background(), txBytes) 
                        rpcClientLocal -> rpcCore : core.BroadcastTxAsync(c.ctx, tx) \
                        \n c å°±æ˜¯ Local ç»“æ„ä½“

                            rpcCore -> CListMempool : env.Mempool.CheckTx(tx, callbackFunc)
                                note over CListMempool
                                    //åˆæ­¥æ£€æŸ¥ï¼š
                                    mem.isFull(txSize)
                                    mem.preCheck(tx)
                                    ====
                                    // å…ˆå°†txåŠ å…¥mempoolä¸­ï¼Œå¹¶ä¿è¯ä¸å‡ºé”™
                                    if !mem.cache.Push(tx)
                                end note

                                CListMempool -> appConnMempool : mem.proxyAppConn.CheckTxAsync(tx)

                                    appConnMempool -> localClient : app.appConn.CheckTxAsync(req)
                                        localClient -> baseapp : app.Application.CheckTx(req)
                                            baseapp -> baseapp #Olive: BaseApp.runTx(mode=<size:20><color:red>runTxModeCheck</color></size>, tx) \
                                            \n <color:DarkGreen>runTxå®šä¹‰åœ¨baseapp.goä¸­</color>
                                                baseapp -> baseapp : BaseApp.txDecoder(txBytes)
                                                    note over baseapp #Green
                                                        txDecoder æ˜¯ BaseApp ç»“æ„ä½“çš„ä¸€ä¸ªå­—æ®µï¼›
                                                        å®ƒæŒ‡å‘ x.auth.tx.DefaultTxDecoder() è¿”å›çš„ä¸€ä¸ªé—­åŒ…å‡½æ•°
                                                    end note
                                                return : tx //types.Tx 

                                                note over baseapp
                                                    msgs = tx.GetMsgs()
                                                    ----
                                                    validateBasicTxMsgs(msgs)
                                                end note 

                                                alt "app.anteHandler != nil; è¿™ä¸ªæ¡ä»¶æ€»æ˜¯ä¸ºçœŸ" 
                                                    baseapp -> baseapp : BaseApp.anteHandler(ctx, tx, true)
                                                        note over baseapp
                                                            anteHandler æ˜¯ BaseApp ç»“æ„ä½“çš„ä¸€ä¸ªå­—æ®µï¼›
                                                            å®ƒæŒ‡å‘ ethermint.app.ante.NewAnteHandler() è¿”å›çš„ä¸€ä¸ªé—­åŒ…å‡½æ•°
                                                        end note
                                                    return
                                                end
                                                
                                                baseapp -> baseapp : BaseApp.runMsgs(runMsgCtx, msgs, mode)
                                                    note over baseapp
                                                        åœ¨ <size:20><color:red>runTxModeCheck</color></size> æ¨¡å¼ä¸‹ï¼Œ
                                                        åªæ˜¯è°ƒç”¨è¿™ä¸ªå‡½æ•°ï¼Œä¸ä¼šå®é™…æ‰§è¡Œæ¶ˆæ¯çš„å¤„ç†é€»è¾‘ã€‚
                                                    end note 
                                                return
                                            return 
                                        return : res=abci.ResponseCheckTx

                                        localClient -> localClient : reqRes=localClient.callback(req,res)
                                        deactivate
                                    return : return reqRes
                                return : return reqRes

                                CListMempool -> CListMempool : reqRes.SetCallback(callbackFunc)
                                note over CListMempool
                                    callbackFunc æ˜¯ CListrpcCore.reqResCb 
                                    è¿”å›çš„é—­åŒ…å‡½æ•°
                                    ----
                                    å®é™…ä¸Šï¼Œè¿™ä¸ª callbackFunc åœ¨è¿™é‡Œç›´æ¥è¢«è°ƒç”¨
                                end note
                                return
                            return :

            rpcCore -> rpcCore : ç­‰å¾… callbackFunc è¢«è°ƒç”¨
            deactivate

                        return
                    return
                return
            return
        return : txHash
    return :

    == ä»rpcServer å¼€å§‹ï¼Œæ˜¯å¦ä¸€ä¸ªå¯èƒ½çš„å…¥å£ ==
    autonumber

    cli -> rpcServer : [ğŸ“¨msg]broadcast_tx_sync, tx
        rpcServer -> rpcCore : BroadcastTxSync(ctx, tx)
        return :
    return :


@enduml

@startuml 2.txDecoderçš„è¯¦ç»†æµç¨‹
    title
        txDecoderçš„è¯¦ç»†æµç¨‹
    end title

    participant txDecoder as "ğŸŒ€<<func>> \n txDecoder"
    participant tx as "ğŸ“¦ï¸<<package>> \n x.auth.tx"
    participant unknownproto as "ğŸ“¦ï¸<<package>> \n codec.unknownproto"
    participant ProtoCodec as "ğŸš§<<struct>> \n codec.ProtoCodec"
    participant typesTx as "ğŸ“¦ï¸<<package>> \n types.tx"
    participant TxRaw as "ğŸš§<<struct>> \n types.tx.TxRaw"
    participant TxBody as "ğŸš§<<struct>> \n types.tx.TxBody"
    participant AuthInfo as "ğŸš§<<struct>> \n types.tx.AuthInfo"
    participant codectypes as "ğŸ“¦ï¸<<package>> \n codec.types"
    participant interfaceRegistry as "ğŸš§<<struct>> \n codec.types.interfaceRegistry"


    autonumber
    autoactivate on

    note over txDecoder, tx
        txDecoder æ˜¯ x.auth.tx.DefaultTxDecoder() è¿”å›çš„ä¸€ä¸ªé—­åŒ…å‡½æ•°
        txDecoder çš„å‡½æ•°å‚æ•°æ˜¯ txBytes []byteï¼Œè¡¨ç¤ºç¼–ç ä¸ºå­—èŠ‚ç çš„äº¤æ˜“
        ----
        é—­åŒ…ä¼ é€’çš„å‚æ•° cdc æ˜¯ struct codec.ProtoCodec
    end note 
    ====
    txDecoder -> tx : rejectNonADR027TxRaw(txBytes)
    return

    note over txDecoder
        var raw tx.TxRaw
    end note

    txDecoder -> unknownproto : unknownproto.RejectUnknownFieldsStrict
    return

    txDecoder -> ProtoCodec : cdc.Unmarshal(txBytes, &raw)
        ProtoCodec -> TxRaw : TxRaw.Unmarshal(txBytes)
            note over TxRaw
                è§£ç åï¼ŒTxRaw çš„å„å­—æ®µè¢«å¡«å……ï¼Œ
                ä½†æ˜¯TxRawçš„å„å­—æ®µä»æ—§æ˜¯ []byte ç±»å‹
                ====
                TxRawçš„3ä¸ªå­—æ®µï¼š
                BodyBytes []byte
                ....
                AuthInfoBytes []byte
                ....
                Signatures [][]byte
            end note
        return
        ProtoCodec -> codectypes : types.UnpackInterfaces(ptr, pc.interfaceRegistry)
            note over codectypes
                å› ä¸ºæ²¡æœ‰ TxRaw ç›¸å…³çš„æ³¨å†Œæ•°æ®ç»“æ„ï¼Œ
                æ‰€ä»¥è¿™é‡Œä»€ä¹ˆéƒ½æ²¡æœ‰åš
            end note 
        return 
    return

    note over txDecoder
        var body tx.TxBody
    end note

    txDecoder -> unknownproto : unknownproto.RejectUnknownFields(raw.BodyBytes, &body)
    return

    txDecoder -> ProtoCodec : cdc.Unmarshal(raw.BodyBytes, &body)
        ProtoCodec -> TxBody : TxBody.Unmarshal(raw.BodyBytes)
            note over TxBody
                è§£ç åï¼ŒTxBody çš„å„å­—æ®µè¢«å¡«å……ï¼Œ
            end note
        return
        ProtoCodec -> codectypes : types.UnpackInterfaces(body, ProtoCodec.interfaceRegistry)
            note over codectypes
                å°† body å¼ºè½¬ä¸º UnpackInterfacesMessage æ¥å£
            end note
            codectypes -> TxBody : msg.UnpackInterfaces(unpacker)
                note over TxBody
                    msg æ˜¯å¼ºè½¬ç±»å‹åçš„å˜é‡åï¼›
                    unpacker æ˜¯ codec.ProtoCodec.interfaceRegistry
                end note 
                TxBody -> typesTx :UnpackInterfaces(unpacker, m.Messages) //må°±æ˜¯TxBody
                    loop "m.Messagesæ˜¯ä¸ªæ•°ç»„ï¼Œéå†æ¯ä¸ªå…ƒç´ "
                        note over typesTx
                            var msg sdk.Msg
                        end note
                        typesTx -> interfaceRegistry : unpacker.UnpackAny(any, &msg)
                            note over interfaceRegistry
                                rt ä»£è¡¨ msg çš„ç±»å‹
                                imap := registry.interfaceImpls[rt] // æ‰¾åˆ°æ¥å£ç±»å‹çš„å®ç°æ˜ å°„
                                typ := imap[any.TypeUrl] //æ ¹æ®TypeURLæŸ¥æ‰¾å®ç°ç±»å‹ï¼›
                                // TypeUrl ä½œä¸ºå­—ç¬¦ä¸²ç¼–ç åœ¨äº† æ¶ˆæ¯ä¸­ï¼Œè¿›è¡Œåˆæ­¥ç•Œé¢æ—¶å³å¯è·å¾—
                                msg = reflect.New(typ.Elem()).Interface().(proto.Message) // ä½¿ç”¨åå°„æ„é€ æ¶ˆæ¯
                                proto.Unmarshal(any.Value, msg) // ä½¿ç”¨ proto è§£ç æ¶ˆæ¯
                            end note
                            interfaceRegistry -> typesTx : <color:red><size:18>é€’å½’è°ƒç”¨ UnpackInterfaces(msg, registry)</size></color>
                            return
                        return
                    end loop 
                return
            return
        return
    return

    note over txDecoder
        var authInfo tx.AuthInfo
    end note

    txDecoder -> unknownproto : unknownproto.RejectUnknownFieldsStrict(raw.AuthInfoBytes, &authInfo)
    return

    txDecoder -> ProtoCodec : cdc.Unmarshal(raw.AuthInfoBytes, &authInfo)
        ProtoCodec -> AuthInfo : AuthInfo.Unmarshal(raw.AuthInfoBytes)
            note over AuthInfo
                è§£ç åï¼ŒAuthInfo çš„å„å­—æ®µè¢«å¡«å……ï¼Œ
            end note
        return

        ProtoCodec -> codectypes : types.UnpackInterfaces(authInfo, ProtoCodec.interfaceRegistry)
            note over codectypes
                å¦‚æœæœ‰ç‹¬ç«‹çš„ SignerInfo æ•°æ®ï¼Œ
                types.UnpackInterfaces() ä¼šé€’å½’è§£ç  SignerInfo å­—æ®µï¼Œ
                è§£ç è¿‡ç¨‹ä¸­ï¼Œä¼šè°ƒç”¨åˆ°å„ä¸ªä¸šåŠ¡æ¨¡å—çš„è§£ç é€»è¾‘ã€‚
                <color:red>ä½†æ˜¯ï¼Œevmæ¨¡å—ä¸­ï¼Œæ•°æ®æ˜¯å’Œç­¾åæ··åˆåœ¨ä¸€èµ·çš„ï¼Œæ‰€ä»¥ä¸ä¼šç”¨åˆ°è¿™ä¸ªé€»è¾‘</color>
            end note
        return       
    return

    note over txDecoder
        ç»„è£…æ•°æ®ï¼Œè¿”å›
    end note
@enduml

@startuml 3.BaseApp.runMsgçš„è¯¦ç»†æµç¨‹
    title 
        BaseApp.runMsgçš„è¯¦ç»†æµç¨‹
    end title

    box cosmos
        participant BaseApp as "ğŸš§<<struct>> baseapp.BaseApp"
        participant EventManager as "ğŸš§<<struct>> types.EventManager"
        participant lambda_1 as "ğŸŒ€<<func>> \n baseapp.MsgServiceRouter.RegisterService \n è¿”å›çš„é—­åŒ…å‡½æ•°\n é—­åŒ…å‡½æ•°1"
        participant lambda_2 as "ğŸŒ€<<func>> \n é—­åŒ…å‡½æ•°1ä¸­å®šä¹‰çš„ interceptor é—­åŒ…å‡½æ•°\n é—­åŒ…å‡½æ•°2"
    end box 

    box ethermint
        participant pb_func as "ğŸŒ€<<func>> \n pbè‡ªåŠ¨ç”Ÿæˆçš„å¤„ç†å‡½æ•° \n x.evm._Msg_EthereumTx_Handler"
        participant lambda_3 as "ğŸŒ€<<func>> \n x.evm._Msg_EthereumTx_Handlerä¸­ç”Ÿæˆçš„handleré—­åŒ…å‡½æ•°"
        participant evmkeeper as "ğŸš§<<struct>> x.evm.keeper.Keeper"
    end box


    autonumber
    autoactivate on

    -> BaseApp : BaseApp.runMsgs(runMsgCtx, msgs, mode)
        note over BaseApp
            runMsgCtx æ˜¯ä¸€ä¸ªç»“æ„ä½“ï¼ŒåŒ…å«äº†ä¸€äº›ä¸Šä¸‹æ–‡ä¿¡æ¯ï¼Œåœ¨è¿›å…¥æœ¬å‡½æ•°å‰ï¼ŒrunMsgCtxå·²ç»
            æ˜¯ä¸€ä¸ªå’Œ mode æœ‰å…³çš„ç»“æ„äº†ï¼›
            ----
            msgs æ˜¯ []sdk.Msg ç±»å‹çš„æ•°ç»„
            ----
            mode æ˜¯ runTxMode ç±»å‹çš„å˜é‡ï¼Œè¡¨ç¤ºæ‰§è¡Œæ¨¡å¼ï¼Œmodeå–å€¼æœ‰ï¼š
            * runTxModeCheck // æ ¡éªŒ
            * runTxModeReCheck // åœ¨commitåï¼Œå¯¹pendingçš„äº‹åŠ¡å†æ ¡éªŒ
            * runTxModeSimulate // æ¨¡æ‹Ÿæ‰§è¡Œ <color:red>[ç³»ç»Ÿæœªä½¿ç”¨è¿™ç§æ¨¡å¼]</color>
            * runTxModeDeliver // è½åœ°å­˜å‚¨å¹¶æ‰§è¡Œäº‹åŠ¡
        end note

        loop å¯¹æ¯ä¸ªmsgè¿›è¡Œå¤„ç†
            alt åªå¤„ç† mode ä¸º runTxModeSimulate runTxModeDeliver çš„åœºæ™¯
                note over BaseApp
                    ä»BaseApp.moduleRouter.msgServiceRouter ä¸­ï¼Œæ ¹æ®msgçš„TypeUrl
                    æ‰¾åˆ°å¯¹åº”çš„ MsgServiceHandler 
                end note 
                note over BaseApp #LimeGreen
                BaseApp.moduleRouter.msgServiceRouter çš„åˆå§‹åŒ–ï¼š
                ====
                <code>
                // RegisterServices registers all module services
                // è¿™ä¸ª Manager å°±æ˜¯ EthermintApp ä¸­çš„ ModuleManager
                func (m *Manager) RegisterServices(cfg Configurator) {
                    for _, module := range m.Modules {
                        // RegisterServices(cfg) æ˜¯
                        module.RegisterServices(cfg)
                    }
                }
                </code>
                end note 
                BaseApp -> lambda_1 :
                    note over lambda_1
                        é—­åŒ…å‡½æ•°çš„å‚æ•°æ˜¯ ctx sdk.Context, msg sdk.Msg
                        é—­åŒ…å‡½æ•°çš„è¿”å›å€¼æ˜¯ sdk.Result
                        ----
                        MsgServiceHandler æ˜¯ baseapp.RegisterServiceè¿”å›çš„ä¸€ä¸ªé—­åŒ…å‡½æ•°ï¼Œ
                        åœ¨è¿™ä¸ªé—­åŒ…å‡½æ•°ä¸­ï¼Œä¼šè°ƒç”¨åˆ°ä¸šåŠ¡æ¨¡å—çš„å¤„ç†é€»è¾‘;
                    end note

                    
                    lambda_1 -> pb_func : å‚æ•°ä¸­åŒ…å«ä¸€ä¸ª interceptor å‡½æ•°æŒ‡é’ˆ
                        note over pb_func 
                            æ„é€ ä¸€ä¸ªé—­åŒ…å‡½æ•°, handler
                        end note 

                        pb_func -> lambda_2 : å‚æ•°ä¸­åŒ…å«åˆšæ‰æ„é€ çš„handler
                            lambda_2 -> lambda_3 : 
                            note over lambda_3
                                å‚æ•°æ˜¯ : ctx context.Context, req interface{}
                                req å¯ä»¥è¢«å¼ºè½¬ä¸º MsgEthereumTx ç±»å‹
                                ....
                                å› ä¸ºåœ¨æ¶ˆæ¯è§£ç æ—¶å·²å®Œæˆäº†å®é™…çš„ç±»å‹è½¬æ¢
                            end note 

                            lambda_3 -> evmkeeper : Keeper.EthereumTx
                                evmkeeper -> evmkeeper : Keeper.ApplyTransaction(ctx, msg)
                                    '
                                return: MsgEthereumTxResponse response 

                                note over evmkeeper
                                    äº‹åŠ¡æœ¬èº«çš„ä¿¡æ¯(ehterumTxHashç­‰)
                                    äº‹åŠ¡æ‰§è¡Œåæ‰€å¾—çš„Log(åˆçº¦ä¸­æŠ›å‡ºçš„event)
                                    ä¸€å¹¶è¢«å°è£…åˆ°ä¸€ä¸ª abci.Event æ•°ç»„ä¸­ã€‚
                                end note

                                evmkeeper -> EventManager : EmitEvents.EmitEvents(events)
                                    note over EventManager
                                        EventManager æ˜¯ contex ä¸­çš„ä¸€ä¸ªå­—æ®µ
                                        ----
                                        EmitEventså‡½æ•°å®ç°ï¼š
                                        <code>
                                            // åªæ˜¯è®°å½•events
                                            em.events = em.events.AppendEvents(events)
                                        </code>
                                    end note
                                return
                            return

                            return : interface{} //å®é™…ä¸Šæ˜¯ MsgEthereumTxResponse

                        return : interface{} //å®é™…ä¸Šæ˜¯ MsgEthereumTxResponse
                    return 


                    note over lambda_1 
                        åœ¨é—­åŒ…å‡½æ•°ä¸­ï¼Œè°ƒç”¨ WrapServiceResult æ„é€ æ‰§è¡Œç»“æœ
                        sdk.Result ç»“æ„ä½“
                        Dataï¼š MsgEthereumTxResponseå¯¹è±¡è¿›è¡Œprotoç¼–ç ï¼›
                        Eventsï¼š ä»contex.EventManagerä¸­å–å‡ºevents
                        MsgResponses: MsgEthereumTxResponse è½¬ä¸º any æ¥å£
                    end note 

                return msgEvents = sdk.Result

            note over BaseApp
                <code>
                msgEvents := sdk.Events{
                    // sdk.EventTypeMessage = "message"
                    // sdk.AttributeKeyAction = "action"
                    // eventMsgName = "/ethermint.evm.v1.MsgEthereumTx"
                    sdk.NewEvent(sdk.EventTypeMessage, sdk.NewAttribute(sdk.AttributeKeyAction, eventMsgName)),
                }
                msgEvents = msgEvents.AppendEvents(msgResult.GetEvents())
                events = events.AppendEvents(msgEvents) // æ”¶é›†æ‰€æœ‰æ¶ˆæ¯æ‰§è¡Œçš„ event
                </code>
                ----
                <code>
                msgResponse := msgResult.MsgResponses[0] // å°±æ˜¯ MsgEthereumTxResponse
                msgResponses = append(msgResponses, msgResponse) // æ”¶é›†æ‰€æœ‰æ¶ˆæ¯æ‰§è¡Œç»“æœ
                </code>
                ----
                <code>
                msgLogs = append(msgLogs, sdk.NewABCIMessageLog(uint32(i), msgResult.Log, msgEvents))
                // å°±æ˜¯å¯¹ msgEvents è¿›è¡Œäº†ä¸€ä¸‹å°è£…ï¼Œ å°† msgEvents è½¬æˆäº†å­—ç¬¦ä¸²
                </code>
                ----
                <code>
                data = makeABCIData(msgResponses)
                </code>
            end note 
            end 
        end
        note over BaseApp 
            <code>
                return &sdk.Result{
                    Data:         data,
                    Log:          strings.TrimSpace(msgLogs.String()),
                    Events:       events.ToABCIEvents(),
                    MsgResponses: msgResponses,
                }
            </code>
        end note 
    return sdk.Result

@enduml

