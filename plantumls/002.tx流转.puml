@startuml 1.txçš„æµè½¬æµç¨‹-1
    title
        txçš„æµè½¬æµç¨‹-CheckTxé˜¶æ®µ
    end title
    
    
    actor cli

    box ethermint
        participant PublicAPI as "ğŸš§<<struct>> \n rpc.namespaces.ethereum.eth.PublicAPI"
        participant rpcBackend as "ğŸš§<<struct>> \n rpc.backend.Backend"
    end box

    box CosmosSDK
        participant clientContext as "ğŸ“¦ï¸<<package>> \n client.Context"
        participant baseapp as "ğŸš§<<struct>> \n baseapp.BaseApp"
    end box

    box Tendermint
        participant rpcServer as "<<åœ¨node.Node.startRPCä¸­æ³¨å†Œ>> \n rpc.core.Routesä¸­ \n æ³¨å†Œçš„æ¶ˆæ¯å¤„ç†å‡½æ•°"


        participant rpcClientLocal as "ğŸš§<<struct>> \n rpc.client.local.Local"
        participant rpcCore as "ğŸ“¦ï¸<<package>> \n rpc.core"

        participant CListMempool as "ğŸš§<<struct>> \n mempool.v0.CListMempool"
        participant appConnMempool as "ğŸš§<<struct>> \n proxy.appConnMempool"
        participant localClient as "ğŸš§<<struct>> \n abci.abcicli.localClient"
    end box

    autonumber
    autoactivate on

    ==ethermint çš„å®é™…å…¥å£==

    
    cli -> PublicAPI : [ğŸ“¨msg]PublicAPI.SendRawTransaction(data) \
    \n data æ˜¯ eth_sendRawTransaction ä¼ é€’çš„æ•°æ®
        PublicAPI -> rpcBackend : e.backend.SendRawTransaction(data) \
        \n e å°±æ˜¯ PublicAPI ç»“æ„ä½“ 
        
            note over rpcBackend
                tx.UnmarshalBinary(data)
                å°†æ•°æ®è§£ç ä¸ºä»¥å¤ªåŠçš„ tx
                ----
                å¯¹ tx è¿›è¡Œæ ¡éªŒ
            end note
            note over rpcBackend
                ethereumTx := &evmtypes.MsgEthereumTx{}
                ethereumTx.FromEthereumTx(tx)
                cosmosTx := ethereumTx.BuildTx(...)
                txBytes := b.clientCtx.TxConfig.TxEncoder()(cosmosTx) // b å°±æ˜¯ Backend
                ----
                æ„é€  cosmos çš„ evm æ¨¡å— message
            end note 
            note over rpcBackend #SkyBlue
                // ä» evm æ ¼å¼çš„äº‹åŠ¡ä¸­è®¡ç®—å‡º txHash
                txHash := ethereumTx.AsTransaction().Hash()
            end note

            note over rpcBackend
                syncCtx := b.clientCtx.WithBroadcastMode(flags.BroadcastSync)
            end note 

            rpcBackend -> clientContext : syncCtx.BroadcastTx(txBytes) 
                clientContext -> clientContext #SkyBlue : ctx.BroadcastTxSync(txBytes)
                    note over clientContext
                        node := ctx.GetNode()
                    end note 
                    clientContext -> rpcClientLocal : node.BroadcastTxSync(context.Background(), txBytes) 
                        rpcClientLocal -> rpcCore : core.BroadcastTxAsync(c.ctx, tx) \
                        \n c å°±æ˜¯ Local ç»“æ„ä½“

                            rpcCore -> CListMempool : env.Mempool.CheckTx(tx, callbackFunc)
                                note over CListMempool
                                    //åˆæ­¥æ£€æŸ¥ï¼š
                                    mem.isFull(txSize)
                                    mem.preCheck(tx)
                                    ====
                                    // å…ˆå°†tx-hashåŠ å…¥mempool-lrucacheä¸­
                                    // å¹¶ä¿è¯ä¸å‡ºé”™
                                    if !mem.cache.Push(tx) {
                                        ...
                                        return 
                                    }
                                end note

                                CListMempool -> appConnMempool : mem.proxyAppConn.CheckTxAsync(tx)

                                    appConnMempool -> localClient : app.appConn.CheckTxAsync(req)
                                        localClient -> baseapp : app.Application.CheckTx(req)
                                            baseapp -> baseapp #Olive: BaseApp.runTx(mode=<size:20><color:red>runTxModeCheck</color></size>, tx) \
                                            \n <color:DarkGreen>runTxå®šä¹‰åœ¨baseapp.goä¸­</color>
                                                baseapp -> baseapp : BaseApp.txDecoder(txBytes)
                                                    note over baseapp #Green
                                                        txDecoder æ˜¯ BaseApp ç»“æ„ä½“çš„ä¸€ä¸ªå­—æ®µï¼›
                                                        å®ƒæŒ‡å‘ x.auth.tx.DefaultTxDecoder() è¿”å›çš„ä¸€ä¸ªé—­åŒ…å‡½æ•°
                                                    end note
                                                return : tx //types.Tx 

                                                note over baseapp
                                                    msgs = tx.GetMsgs()
                                                    ----
                                                    validateBasicTxMsgs(msgs)
                                                end note 

                                                alt "app.anteHandler != nil; è¿™ä¸ªæ¡ä»¶æ€»æ˜¯ä¸ºçœŸ" 
                                                    baseapp -> baseapp : BaseApp.anteHandler(ctx, tx, true)
                                                        note over baseapp
                                                            anteHandler æ˜¯ BaseApp ç»“æ„ä½“çš„ä¸€ä¸ªå­—æ®µï¼›
                                                            å®ƒæŒ‡å‘ ethermint.app.ante.NewAnteHandler() è¿”å›çš„ä¸€ä¸ªé—­åŒ…å‡½æ•°
                                                        end note
                                                    return
                                                end
                                                
                                                baseapp -> baseapp : BaseApp.runMsgs(runMsgCtx, msgs, mode)
                                                    note over baseapp
                                                        åœ¨ <size:20><color:red>runTxModeCheck</color></size> æ¨¡å¼ä¸‹ï¼Œ
                                                        åªæ˜¯è°ƒç”¨è¿™ä¸ªå‡½æ•°ï¼Œä¸ä¼šå®é™…æ‰§è¡Œæ¶ˆæ¯çš„å¤„ç†é€»è¾‘ã€‚
                                                    end note 
                                                return
                                            return 
                                        return : res=abci.ResponseCheckTx

                                        localClient -> localClient : reqRes=localClient.callback(req,res)
                                        deactivate
                                    return : return reqRes
                                return : return reqRes

                                CListMempool -> CListMempool : reqRes.SetCallback(callbackFunc)
                                note over CListMempool #FB595D
                                    callbackFunc æ˜¯ CListMempool.reqResCb 
                                    è¿”å›çš„é—­åŒ…å‡½æ•°
                                    ----
                                    å®é™…ä¸Šï¼Œè¿™ä¸ª callbackFunc åœ¨è¿™é‡Œç›´æ¥è¢«è°ƒç”¨
                                    ====
                                    åœ¨è¿™ä¸ªcallbackå‡½æ•°ä¸­ï¼Œå¦‚æœABCIæ¥å£è¿”å›ç»“æœæ²¡æœ‰é”™è¯¯ï¼Œ
                                    txå°†è¢«æ·»åŠ åˆ°mempoolä¸­
                                end note
                                return
                            return :

            rpcCore -> rpcCore : ç­‰å¾… callbackFunc è¢«è°ƒç”¨
            deactivate

                        return
                    return
                return
            return
        return : txHash
    return :

    == ä»rpcServer å¼€å§‹ï¼Œæ˜¯å¦ä¸€ä¸ªå¯èƒ½çš„å…¥å£ ==
    autonumber

    cli -> rpcServer : [ğŸ“¨msg]broadcast_tx_sync, tx
        rpcServer -> rpcCore : BroadcastTxSync(ctx, tx)
        return :
    return :


@enduml

@startuml 2.txçš„æµè½¬æµç¨‹-2
    title
        txçš„æµè½¬æµç¨‹-DeliverTxé˜¶æ®µ
    end title

    box Tendermint
        participant ConsensusState as "ğŸš§<<struct>> \n consensus.State"
        participant csVote as "ğŸš§<<struct>> \n consensus.types.HeightVoteSet"
        participant WAL as "ğŸš§<<struct>> \n consensus.BaseWAL"
        participant EventBus as "ğŸš§<<struct>> \n types.EventBus"
        participant eventSwitch as "ğŸš§<<struct>> \n libs.events.eventSwitch"
        participant BlockExecutor as "ğŸš§<<struct>> \n state.BlockExecutor"
        participant state as "ğŸ“¦ï¸<<package>> \n state"
        participant dbStore as "ğŸš§<<struct>> \n state.dbStore"
        participant BlockStore as "ğŸš§<<struct>> \n store.BlockStore"

        participant CListMempool as "ğŸš§<<struct>> \n mempool.v0.CListMempool"

        participant appConnConsensus as "ğŸš§<<struct>> \n proxy.appConnConsensus"
        participant localClient as "ğŸš§<<struct>> \n abci.abcicli.localClient"
    end box

    box CosmosSDK
        participant clientContext as "ğŸ“¦ï¸<<package>> \n client.Context"
        participant baseapp as "ğŸš§<<struct>> \n baseapp.BaseApp"

        participant ModuleManager as "ğŸš§<<struct>> \n types.module.Manager"

        participant CacheMultiStore as "ğŸš§<<struct>> \n store.cachemulti.Store"
        participant RootMultiStore as "ğŸš§<<struct>> \n store.rootmulti.Store"
    end box

    box ethermint
        participant EthermintApp as "ğŸš§<<struct>> \n app.EthermintApp"
    end box

    autonumber
    autoactivate on

    ==åœ¨ä¸€ä¸ªåç¨‹é‡Œå·¥ä½œï¼Œæ”¶åˆ°æ¶ˆæ¯å³åšå¦‚ä¸‹çš„å¤„ç†==
    -> ConsensusState : cs.handleMsg(mi)ï¼Œ // var mi msgInfo
        note over ConsensusState
            æ¶ˆæ¯çš„ç§ç±»åŒ…æ‹¬ï¼š
            * ProposalMessage; 
            * BlockPartMessage;
            * VoteMessage
            ====
            <color:red>æˆ‘ä»¬ä»…å…³æ³¨å¯¹ VoteMessage çš„å¤„ç†</color>
        end note

        alt "æ¶ˆæ¯ç±»å‹ä¸º VoteMessage "
            ConsensusState -> ConsensusState #Chocolate : cs.tryAddVote(msg.Vote, peerID)
                ConsensusState -> ConsensusState #Cyan : cs.addVote(vote, peerID)
                    note over ConsensusState
                        è¾“å‡ºæ—¥å¿—ä¿¡æ¯â€œadding voteâ€
                    end note 
                    note over ConsensusState
                        <code>
                        if vote.Height+1 == cs.Height && vote.Type == cmtproto.PrecommitType{...}
                        </code>
                        å¤„ç† é’ˆå¯¹å‰ä¸€ä¸ªåŒºå—çš„ precommitï¼Œ //<color:red><b>æœ‰ç–‘é—®ï¼Ÿï¼Ÿï¼Ÿ
                    end note 

                    ConsensusState -> csVote : cs.Votes.AddVote(vote, peerID)
                    return

                    ConsensusState -> EventBus : cs.eventBus.PublishEventVote(types.EventDataVote{Vote: vote})
                    return

                    ConsensusState -> eventSwitch : cs.evsw.FireEvent(types.EventVote, vote) //types.EventVote = "Vote" 
                    return

                    note over ConsensusState
                        æ¥ä¸‹æ¥æ ¹æ® vote.Type åšä¸åŒçš„å¤„ç†
                        ----
                        vote.Typeçš„ä¸åŒå–å€¼ï¼š
                        * PrevoteType
                        * PrecommitType
                        ====
                        åªå…³æ³¨ PrecommitType çš„å¤„ç†
                        æ ¹æ®çŠ¶æ€è¿ç§»ï¼Œæ”¶åˆ° 2/3+ çš„ precommit åï¼Œä¼šè¿›å…¥ Commit é˜¶æ®µ
                    end note 
                    alt "vote.Type = PrecommitType"
                        note over ConsensusState
                            <code>
                            // å–å‡ºprecommitsé›†åˆ
                            precommits := cs.Votes.Precommits(vote.Round)
                            // åˆ¤æ–­æ˜¯å¦æœ‰2/3+çš„precommit
                            blockID, ok := precommits.TwoThirdsMajority()
                            </code>
                        end note
                        alt "ok=true, æ”¶åˆ°äº†2/3+èŠ‚ç‚¹çš„Precommitä¿¡æ¯"
                            ConsensusState -> ConsensusState #DarkGreen :cs.enterCommit(height, vote.Round)
                                note over ConsensusState
                                    åœ¨ enterCommit çš„ defer å‡½æ•°ä¸­ï¼Œ
                                    ä¼šè°ƒç”¨ cs.tryFinalizeCommit(height)
                                    ----
                                    <code>
                                    cs.CommitTime = cmttime.Now()
                                    cs.newStep()
                                    cs.tryFinalizeCommit(height)
                                    </code>
                                end note 
                                ConsensusState -> ConsensusState #FF00FF: cs.tryFinalizeCommit(height)
                                    note over ConsensusState
                                        ä¸€äº›æ£€æŸ¥å·¥ä½œ
                                    end note 
                                    ConsensusState -> ConsensusState #7FFF00: cs.finalizeCommit(height)
                                        note over ConsensusState
                                            block = cs.ProposalBlock
                                        end note 

                                        ConsensusState -> BlockExecutor : cs.blockExec.ValidateBlock(cs.state, block)
                                        return

                                        ConsensusState -> BlockStore : â­ï¸cs.blockStore.SaveBlock(block, blockParts, seenCommit) <size:18><color:DarkGreen><b>//å­˜å‚¨åŒºå—
                                        return
                                        
                                        ConsensusState -> WAL : cs.wal.WriteSync()
                                        return

                                        ConsensusState -> BlockExecutor :cs.blockExec.ApplyBlock(stateCopy, blockID, block)
                                            BlockExecutor -> state : execBlockOnProxyApp(, blockExec.proxyApp, block, blockExec.store,)
                                                note over state
                                                    åœ¨ execBlockOnProxyApp å‡½æ•°ä¸­
                                                    ====
                                                    å®šä¹‰é—­åŒ…å›è°ƒå‡½æ•° proxyCb, ç”¨äºå¤„ç†æ¯ä¸ªäº‹åŠ¡çš„æ‰§è¡Œç»“æœ
                                                    åœ¨ proxyCb ä¸­æ”¶é›†äº†æ¯ä¸ªäº‹åŠ¡çš„æ‰§è¡Œç»“æœ
                                                end note 
                                                
                                                state -> appConnConsensus : proxyAppConn.SetResponseCallback(proxyCb)
                                                return

                                                state -> appConnConsensus : proxyAppConn.BeginBlockSync(...)
                                                    appConnConsensus -> localClient :app.appConn.BeginBlockSync(req)
                                                        localClient -> baseapp : app.Application.BeginBlock(req)
                                                            note over baseapp
                                                                // åœ¨cosmoså±‚åšæ ¡éªŒ
                                                                app.validateHeight(req) 
                                                                ====
                                                                // è®¾ç½® deliverState çš„ context
                                                                app.deliverState.ctx 
                                                            end note 
                                                            baseapp -> EthermintApp : app.beginBlocker(app.deliverState.ctx, req)
                                                                note over baseapp, EthermintApp
                                                                    é€šè¿‡åœ¨åˆå§‹åŒ–æ—¶è°ƒç”¨ 
                                                                    app.SetBeginBlocker(app.BeginBlocker)
                                                                    å°† baseapp.BeginBlocker è®¾ç½®ä¸º EthermintApp.BeginBlocker
                                                                end note 
                                                                note over EthermintApp
                                                                    æ‰§è¡Œä¸Šä¸‹æ–‡åœ¨ EthermintApp.BeginBlocker å‡½æ•°ä¸­
                                                                end note

                                                                EthermintApp -> ModuleManager : app.mm.BeginBlock(ctx, req)
                                                                    note over ModuleManager
                                                                        <color:DarkGreen>æŒ‰ OrderBeginBlockers ä¸­å®šä¹‰çš„é¡ºåºï¼Œä¾æ¬¡è°ƒç”¨æ¯ä¸ªæ¨¡å—çš„ BeginBlock å‡½æ•°
                                                                        ----
                                                                        <code>
                                                                        for _, moduleName := range m.OrderBeginBlockers {
                                                                            module, ok := m.Modules[moduleName].(BeginBlockAppModule)
                                                                            if ok {
                                                                                module.BeginBlock(ctx, req)
                                                                            }
                                                                        }
                                                                        </code>
                                                                    end note 
                                                                    note over ModuleManager
                                                                        ä»contextä¸­å–å‡ºeventæ•°æ®ä½œä¸ºè¿”å›å€¼ï¼š
                                                                        ----
                                                                        <code>
                                                                        return abci.ResponseBeginBlock{
                                                                            Events: ctx.EventManager().ABCIEvents(),
                                                                        }
                                                                        </code>
                                                                    end note 
                                                                return
                                                                note over baseapp
                                                                    å¦‚æœæ³¨å†Œäº† ABCIListener, 
                                                                    åˆ™è°ƒç”¨ ABCIListener.ListenBeginBlock(...), å¯¹å…¶å‘å‡ºé€šçŸ¥
                                                                    ----
                                                                    Ethermintå®ç°ä¸­ï¼Œæ²¡æœ‰æ³¨å†Œ ABCIListener
                                                                end note
                                                            return
                                                        return abciResponses.BeginBlock
                                                    return : abciResponses.BeginBlock
                                                return : abciResponses.BeginBlock

                                                loop "é’ˆå¯¹åŒºå—ä¸­çš„æ¯ä¸ªTx"
                                                    state -> appConnConsensus :proxyAppConn.DeliverTxAsync(abci.RequestDeliverTx{Tx: tx})
                                                        appConnConsensus -> localClient : app.appConn.DeliverTxAsync(req)
                                                            localClient -> baseapp : app.Application.DeliverTx(params)
                                                                baseapp -> baseapp : app.runTx(runTxModeDeliver, req.Tx)
                                                                    note over baseapp 
                                                                        runTxçš„è¯¦ç»†æµç¨‹ï¼Œå‚çœ‹ CheckTx é˜¶æ®µçš„æµç¨‹
                                                                    end note 
                                                                return
                                                            return : ResponseDeliverTx

                                                            note over localClient
                                                                ä½¿ç”¨å›è°ƒå‡½æ•°
                                                            end note 
                                                        return
                                                    return ://åœ¨ proxyCb ä¸­æ”¶é›†äº†æ¯ä¸ªäº‹åŠ¡çš„æ‰§è¡Œç»“æœ
                                                end loop

                                                state -> appConnConsensus : proxyAppConn.EndBlockSync(...)
                                                    appConnConsensus -> localClient : app.appConn.EndBlockSync(req)
                                                        localClient -> baseapp : app.Application.EndBlock(req)
                                                            baseapp -> EthermintApp : app.endBlocker(app.deliverState.ctx, req)
                                                                note over baseapp, EthermintApp
                                                                    åˆå§‹åŒ–æ–¹å¼å’Œ BeginBlocker ä¸€æ ·
                                                                end note
                                                                note over EthermintApp
                                                                    æ‰§è¡Œä¸Šä¸‹æ–‡åœ¨ EthermintApp.EndBlocker å‡½æ•°ä¸­
                                                                end note 

                                                                EthermintApp -> ModuleManager : app.mm.EndBlock(ctx, req)
                                                                    note over ModuleManager
                                                                        å’Œ BeginBlock ç±»ä¼¼ï¼Œ
                                                                        æŒ‰ OrderEndBlockers å®šä¹‰çš„é¡ºåºï¼Œä¾æ¬¡è°ƒç”¨æ¯ä¸ªæ¨¡å—çš„ EndBlock å‡½æ•°
                                                                        æ¨¡å—EndBlockçš„è¿”å›å€¼ç±»å‹æ˜¯ï¼š[]abci.ValidatorUpdate
                                                                    end note 
                                                                    note over ModuleManager #FB8180
                                                                        EndBlockçš„è¿”å›å€¼ï¼ŒåŒ…å«äº†Validatorçš„æ›´æ–°ä¿¡æ¯
                                                                        ----
                                                                        <code>
                                                                        return abci.ResponseEndBlock{
                                                                            ValidatorUpdates: validatorUpdates,
                                                                            Events: ctx.EventManager().ABCIEvents(),
                                                                        }
                                                                        </code>
                                                                    end note
                                                                return
                                                            return
                                                        return abciResponses.EndBlock
                                                    return : abciResponses.EndBlock
                                                return : abciResponses.EndBlock
                                            return : abciResponses

                                            BlockExecutor -> dbStore : blockExec.store.SaveABCIResponses(block.Height, abciResponses)
                                                note over dbStore
                                                    å­˜å‚¨ ABCI æ¥å£çš„è¿”å›ç»“æœ
                                                end note 
                                            return

                                            group #SkyBlue "æ›´æ–° validator" 
                                                note over BlockExecutor
                                                    // å–å‡ºEndBlockçš„è¿”å›å€¼ä¸­çš„Validatoræ›´æ–°ä¿¡æ¯
                                                    abciValUpdates := abciResponses.EndBlock.ValidatorUpdates
                                                end note 
                                                BlockExecutor -> state : validateValidatorUpdates(abciValUpdates, state.ConsensusParams.Validator)
                                                return
                                                note over BlockExecutor
                                                    // æ ¼å¼è½¬æ¢
                                                    validatorUpdates = types.PB2TM.ValidatorUpdates(abciValUpdates)
                                                end note 
                                                BlockExecutor -> state : updateState(state, blockID, &block.Header, abciResponses, validatorUpdates)
                                                return
                                            end group

                                            BlockExecutor -> BlockExecutor #Pink : blockExec.Commit(state, block, abciResponses.DeliverTxs)
                                                BlockExecutor -> CListMempool : blockExec.mempool.FlushAppConn()
                                                    note over CListMempool

                                                    end note
                                                return

                                                BlockExecutor -> appConnConsensus : blockExec.proxyApp.CommitSync()
                                                    appConnConsensus -> localClient : app.appConn.CommitSync()
                                                        localClient -> baseapp : app.Application.Commit()
                                                            baseapp -> CacheMultiStore : app.deliverState.ms.Write()
                                                            return

                                                            baseapp -> RootMultiStore : app.cms.Commit()
                                                            return
                                                        return
                                                    return
                                                return
                                            return
                                        return
                                    return
                                return
                            return
                        end alt 
                    end alt
                return
                note over ConsensusState
                    å¦‚æœå‡ºç°é”™è¯¯ï¼Œè¿›è¡Œå¤„ç†
                end note 
            return
        end alt 


    return


@enduml

@startuml 3.txçš„å¤„ç†æµç¨‹-æ³³é“å›¾
    title 
        txçš„å¤„ç†æµç¨‹-æ³³é“å›¾
    end title


    |#AE71F5|eRPC|Ethermint.EthRpcServer

    |#9BE3E4|baseapp|CosmosSDK.BaseApp

    |#748AF9|mempool|Tendermint.Mempool
    |#3450DE|consensus|<color:White>Tendermint.Consensus
    |#0C2FE5|bcStore|<color:White>Tendermint.BlockChainStore


    |eRPC|
        start

        :æ¥æ”¶æ»¡è¶³ä»¥å¤ªåŠRPCæ¥å£æ ‡å‡†çš„è¯·æ±‚;

        :å°è£…æˆcosmosæ ¼å¼çš„tx
        ï¼ˆä½œä¸ºtxä¸­çš„ä¸€ä¸ªmessageï¼‰;

    |mempool|
        :tx-hashè¢«åŠ å…¥æœ¬åœ°mempool-cacheä¸­;

        #LimeGreen:é€šè¿‡ ABCI æ¥å£çš„ CheckTx å‡½æ•°ï¼Œ
        å°†txä¼ é€’ç»™ CosmosSDK å¤„ç†<

    |baseapp|
        package "ä»¥ mode=runTxModeCheck è°ƒç”¨runTxå‡½æ•°" {
            :å¯¹txè¿›è¡Œè§£ç ;
            note right
                é‡‡ç”¨ TypeURL+åå°„ çš„æ–¹å¼ï¼Œ
            end note 

            :è°ƒç”¨EthermintAppæ³¨å†Œçš„anteHandlerå¯¹txè¿›è¡Œæ ¡éªŒ;
        }

    |mempool|
        :CheckTx æ£€æŸ¥æ¶ˆæ¯é€šè¿‡ï¼Œ
        å°†txåŠ å…¥æœ¬åœ°mempoolä¸­;

        :è¿›å…¥txçš„å¹¿æ’­å’Œå…±è¯†æµç¨‹|

    |consensus|
        :å…±è¯†æµç¨‹çš„æ¶ˆæ¯é€šä¿¡å®Œæˆ
        (æ”¶åˆ°2/3+èŠ‚ç‚¹çš„Precommitæ¶ˆæ¯)/

    |bcStore|
        :å­˜å‚¨åŒºå—;

    |consensus|
        #LimeGreen:é€šè¿‡ ABCI æ¥å£çš„ BeginBlock å‡½æ•°ï¼Œ
        é€šçŸ¥ CosmosSDK æ–°çš„åŒºå—å·²ç»ç”Ÿæˆ<

    |baseapp|
        :æ ¹æ® ModuleManager ä¸­è®¾å®šçš„æ¨¡å—è°ƒç”¨é¡ºåºï¼Œ
        ä¾æ¬¡è°ƒç”¨æ¯ä¸ªæ¨¡å—çš„ BeginBlock å‡½æ•°;
    
    |consensus|
        #LimeGreen:é€šè¿‡ ABCI æ¥å£çš„ DeliverTx å‡½æ•°ï¼Œ
        å°† tx ä¼ é€’ç»™ CosmosSDK å¤„ç†<

    |baseapp|
        package "ä»¥ mode=runTxModeDeliver è°ƒç”¨runTxå‡½æ•°" {
            :å¯¹txè¿›è¡Œè§£ç ;

            :è°ƒç”¨EthermintAppæ³¨å†Œçš„anteHandlerå¯¹txè¿›è¡Œæ ¡éªŒ;

            :ä»Txä¸­é€ä¸ªå–å‡ºmessage, è°ƒç”¨æ¨¡å—æ³¨å†Œçš„å¤„ç†å‡½æ•°è¿›è¡Œå¤„ç†;
        }

    |consensus|
        #LimeGreen:é€šè¿‡ ABCI æ¥å£çš„ EndBlock å‡½æ•°ï¼Œ
        é€šçŸ¥ CosmosSDK æœ¬åŒºå—çš„å¤„ç†å·²ç»å®Œæˆ<

    |baseapp|
        :æ ¹æ® ModuleManager ä¸­è®¾å®šçš„æ¨¡å—è°ƒç”¨é¡ºåºï¼Œ
        ä¾æ¬¡è°ƒç”¨æ¯ä¸ªæ¨¡å—çš„ EndBlock å‡½æ•°;

    |consensus|
        :å­˜å‚¨ ABCI æ‰§è¡Œç»“æœï¼Œ
        æ ¹æ®EndBlockçš„è¿”å›å€¼æ›´æ–°validatorä¿¡æ¯;

        #LimeGreen:é€šè¿‡ ABCI æ¥å£çš„ Commit å‡½æ•°ï¼Œ
        é€šçŸ¥ CosmosSDK æœ¬åŒºå—çš„å¤„ç†å·²ç»å®Œæˆ<

    |baseapp|
        :å°†æœ¬åŒºå—çš„çŠ¶æ€å­˜å‚¨åˆ°æ•°æ®åº“ä¸­;

        stop 

@enduml

@startuml 4.æŸ¥è¯¢æµç¨‹åºåˆ—å›¾
    title 
        æŸ¥è¯¢æµç¨‹åºåˆ—å›¾
        ä»¥ eth_call ä¸ºä¾‹
    end title

    actor cli

    box ethermint
        participant PublicAPI as "ğŸš§<<struct>> \n rpc.namespaces.ethereum.eth.PublicAPI"
        participant rpcBackend as "ğŸš§<<struct>> \n rpc.backend.Backend"

        participant evmQueryClient as "ğŸš§<<struct>> \n x.evm.types.queryClient"
        participant evmKeeper as "ğŸš§<<struct>> \n x.evm.keeper.Keeper"

        participant EthCallHandler as "ğŸŒ€<<func>> \n x.evm.types._Query_EthCall_Handler"
    end box

    box CosmosSDK
        participant clientContext as "ğŸ“¦ï¸<<package>> \n client.Context"
        participant baseapp as "ğŸš§<<struct>> \n baseapp.BaseApp"

        participant lambda_1 as "ğŸŒ€<<func>> \n baseapp.MsgServiceRouter.RegisterService \n è¿”å›çš„é—­åŒ…å‡½æ•°\n é—­åŒ…å‡½æ•°1"
    end box

    box Tendermint
        participant rpcClientLocal as "ğŸš§<<struct>> \n rpc.client.local.Local"
        participant rpcCore as "ğŸ“¦ï¸<<package>> \n rpc.core"

        participant BlockStore as "ğŸš§<<struct>> \n store.BlockStore"

        participant appConnQuery as "ğŸš§<<struct>> \n proxy.appConnQuery"
        participant localClient as "ğŸš§<<struct>> \n abci.abcicli.localClient"
    end box

    autonumber
    autoactivate on

    cli -> PublicAPI : Call(...)
        PublicAPI -> rpcBackend : e.backend.DoCall(args, blockNum)
            rpcBackend -> rpcBackend #MediumSeaGreen: b.TendermintBlockByNumber(blockNr) \n//blockNr å°±æ˜¯ block-number
                note over rpcBackend
                    // å¦‚æœæ²¡æœ‰ä¼ é€’ blockNumberï¼Œåˆ™ä»åº”ç”¨çŠ¶æ€è·å–è¿™ä¸ªå€¼
                    n, err := b.BlockNumber()
                end note 

                rpcBackend -> rpcClientLocal : b.clientCtx.Client.Block(b.ctx, &height)
                    rpcClientLocal -> rpcCore : core.Block(c.ctx, height)
                        rpcCore -> BlockStore: env.BlockStore.LoadBlock(height)
                        return
                        rpcCore -> BlockStore: env.BlockStore.LoadBlockMeta(height)
                        return: types.BlockMeta blockMeta
                    return 
                return :ctypes.ResultBlock
            return

            note over rpcBackend
                // æ„é€ è¯·æ±‚
                <code>
                req := evmtypes.EthCallRequest{
                    Args:            bz,
                    GasCap:          b.RPCGasCap(),
                    ProposerAddress: sdk.ConsAddress(header.Block.ProposerAddress),
                    ChainId:         b.chainID.Int64(),
                }
                </code>
                ----
                //å‡†å¤‡context
                <code>
                ctx := rpctypes.ContextWithHeight(blockNr.Int64())
                ctx, cancel = context.WithTimeout(ctx, timeout)
                </code>
            end note 
            rpcBackend -> evmQueryClient : b.queryClient.EthCall(ctx, &req)
                evmQueryClient -> clientContext : c.cc.Invoke(ctx, "/ethermint.evm.v1.Query/EthCall", in, out, opts...)
                alt "ctx.GRPCClient != nil  //Case 2-1. Invoke grpc."
                    note over clientContext #Tomato
                        åœ¨ app.toml çš„ grpc è¢«å¼€å¯æ—¶ï¼Œä¼šè¿›å…¥è¿™ä¸ªåˆ†æ”¯
                        æœ€å¥½å°†å…¶å…³é—­
                        <code>
                        [grpc]
                        # Enable defines if the gRPC server should be enabled.
                        enable = false
                        # Address defines the gRPC server address to bind to.
                        address = "0.0.0.0:9090"
                        </code>
                    end note 
                    note over clientContext
                        ctx.GRPCClient.Invoke(grpcCtx, method, req, reply, opts...)
                        è¿›å…¥è¿™ä¸ªå¤„ç†åˆ†æ”¯ï¼Œä¼šä½¿ç”¨rpcæ¥å£å‘ BaseApp å¯åŠ¨çš„ä¸€ä¸ª RPC æœåŠ¡å‘é€è¯·æ±‚
                        æœ€ç»ˆä¼šè°ƒç”¨ BaseAPP.RegisterGRPCServer æ³¨å†Œçš„å¤„ç†å‡½æ•°ä¸­è¿›è¡Œå¤„ç†ã€‚
                        ====
                        è¿™æ˜¯ä¸ªä½æ•ˆæ–¹å¼ã€‚
                    end note 
                else "Case 2-2. Querying state via abci query"
                    note over clientContext
                        // å¯¹è¯·æ±‚è¿›è¡Œç¼–ç 
                        <code>
                        reqBz, err := ctx.gRPCCodec().Marshal(req)

                        abciReq := abci.RequestQuery{
                        Path:   method,
                        Data:   reqBz,
                        Height: ctx.Height,
                        }
                        </code>
                    end note 
                    clientContext -> clientContext #DodgerBlue: ctx.QueryABCI(abciReq)
                        clientContext -> clientContext #MediumOrchid: ctx.queryABCI(req)
                            note over clientContext
                                <code>
                                opts := rpcclient.ABCIQueryOptions{
                                    Height: queryHeight,
                                    Prove:  req.Prove,
                                }
                                </code>
                            end note 
                            clientContext -> rpcClientLocal: node.ABCIQueryWithOptions(context.Background(),req.Path,req.Data,opts)
                                rpcClientLocal -> rpcCore : core.ABCIQuery(c.ctx,path,data,opts.Height,opts.Prove)
                                    rpcCore -> appConnQuery: env.ProxyAppQuery.QuerySync(...)
                                        appConnQuery -> localClient: app.appConn.QuerySync(reqQuery)
                                            localClient -> baseapp: app.Application.Query(req)
                                                note over baseapp
                                                    //ä½¿ç”¨äº† gRPC server çš„è·¯ç”±è¡¨
                                                    grpcHandler := app.grpcQueryRouter.Route(req.Path)
                                                end note
                                                baseapp -> baseapp #Magenta:app.handleQueryGRPC(grpcHandler, req)
                                                    note over baseapp
                                                        handler å°±æ˜¯å®å‚ grpcHandler
                                                    end note 
                                                    baseapp -> lambda_1 : handler(ctx, req) 
                                                        note over lambda_1
                                                            // methodHandler å’Œ handler çš„æ¥æºï¼š
                                                            <code>
                                                            RegisterService(sd, handler) {
                                                                for _, method := range sd.Methods{
                                                                    ...
                                                                    ethodHandler := method.Handler
                                                                }
                                                            }
                                                            </code>
                                                        end note 
                                                        lambda_1 -> EthCallHandler : methodHandler(handler, sdk.WrapSDKContext(ctx),...)
                                                            note over EthCallHandler
                                                                å°†å®å‚ handler å¼ºåˆ¶è½¬æ¢ä¸º QueryServer
                                                            end note 
                                                            EthCallHandler -> evmKeeper : srv.(QueryServer).EthCall(ctx, in)
                                                                note over evmKeeper
                                                                    // ä¼ é€’çš„contexä¸­ï¼Œä¸ºcallè°ƒç”¨å‡†å¤‡å¥½äº†ç›¸åº”çš„ç¯å¢ƒ
                                                                    ctx := sdk.UnwrapSDKContext(c)
                                                                end note
                                                                evmKeeper -> evmKeeper #Fuchsia : k.ApplyMessageWithConfig(ctx, msg, nil, false, cfg, txConfig)
                                                                    note over evmKeeper
                                                                        åˆ›å»ºevmå®ä¾‹ï¼Œæ‰§è¡Œè°ƒç”¨
                                                                        å½¢å‚ commit = false
                                                                    end note
                                                                return : MsgEthereumTxResponse
                                                        return
                                                    return
                                                return
                                            return
                                        return
                                    return : resQuery
                                return
                            return
                        return
                    return : reqBz
                end alt 
                return
            return
        return
    return


@enduml

@startuml 5.æŸ¥è¯¢æµç¨‹-æ³³é“å›¾
    title 
        æŸ¥è¯¢æµç¨‹-æ³³é“å›¾
        ä»¥ eth_call ä¸ºä¾‹
    end title

    |#AE71F5|eRPC|Ethermint.EthRpcServer

    |#9BE3E4|baseapp|CosmosSDK.BaseApp

    |#748AF9|query|Tendermint.Query
    |#0C2FE5|bcStore|<color:White>Tendermint.BlockChainStore

    |eRPC|
        start

        :æ¥æ”¶æ»¡è¶³ä»¥å¤ªåŠRPCæ¥å£æ ‡å‡†çš„è¯·æ±‚;

        :å¦‚æœæ²¡æœ‰æŒ‡å®šé«˜åº¦ï¼Œä½¿ç”¨æœ€æ–°é«˜åº¦;
    
    |bcStore|
        :å–å‡ºæŒ‡å®šé«˜åº¦çš„åŒºå—;
        note right
            å®é™…åªä½¿ç”¨åŒºå—ä¸­çš„
            ProposerAddress ä¿¡æ¯
        end note

    |eRPC|
        :å¯¹è¯·æ±‚ä¿¡æ¯è¿›è¡Œç¼–ç ;

    |query|
        #LimeGreen:é€šè¿‡ ABCI æ¥å£çš„ Query å‡½æ•°ï¼Œ
        å°†è¯·æ±‚ä¼ é€’ç»™ CosmosSDK å¤„ç†<

    |baseapp|
        :æ ¹æ®å¯åŠ¨æ—¶æ³¨å†Œçš„è·¯ç”±ä¿¡æ¯ï¼Œ
        è°ƒç”¨å¯¹åº”çš„æ³¨å†Œå‡½æ•°è¿›è¡Œå¤„ç†
        ----
        å„ä¸ªæ¨¡å—å¯¹åº”çš„å¤„ç†å‡½æ•°è¢«è°ƒç”¨;
    
    stop

@enduml


@startuml 8.txDecoderçš„è¯¦ç»†æµç¨‹
    title
        txDecoderçš„è¯¦ç»†æµç¨‹
    end title

    participant txDecoder as "ğŸŒ€<<func>> \n txDecoder"
    participant tx as "ğŸ“¦ï¸<<package>> \n x.auth.tx"
    participant unknownproto as "ğŸ“¦ï¸<<package>> \n codec.unknownproto"
    participant ProtoCodec as "ğŸš§<<struct>> \n codec.ProtoCodec"
    participant typesTx as "ğŸ“¦ï¸<<package>> \n types.tx"
    participant TxRaw as "ğŸš§<<struct>> \n types.tx.TxRaw"
    participant TxBody as "ğŸš§<<struct>> \n types.tx.TxBody"
    participant AuthInfo as "ğŸš§<<struct>> \n types.tx.AuthInfo"
    participant codectypes as "ğŸ“¦ï¸<<package>> \n codec.types"
    participant interfaceRegistry as "ğŸš§<<struct>> \n codec.types.interfaceRegistry"


    autonumber
    autoactivate on

    note over txDecoder, tx
        txDecoder æ˜¯ x.auth.tx.DefaultTxDecoder() è¿”å›çš„ä¸€ä¸ªé—­åŒ…å‡½æ•°
        txDecoder çš„å‡½æ•°å‚æ•°æ˜¯ txBytes []byteï¼Œè¡¨ç¤ºç¼–ç ä¸ºå­—èŠ‚ç çš„äº¤æ˜“
        ----
        é—­åŒ…ä¼ é€’çš„å‚æ•° cdc æ˜¯ struct codec.ProtoCodec
    end note 
    ====
    txDecoder -> tx : rejectNonADR027TxRaw(txBytes)
    return

    note over txDecoder
        var raw tx.TxRaw
    end note

    txDecoder -> unknownproto : unknownproto.RejectUnknownFieldsStrict
    return

    txDecoder -> ProtoCodec : cdc.Unmarshal(txBytes, &raw)
        ProtoCodec -> TxRaw : TxRaw.Unmarshal(txBytes)
            note over TxRaw
                è§£ç åï¼ŒTxRaw çš„å„å­—æ®µè¢«å¡«å……ï¼Œ
                ä½†æ˜¯TxRawçš„å„å­—æ®µä»æ—§æ˜¯ []byte ç±»å‹
                ====
                TxRawçš„3ä¸ªå­—æ®µï¼š
                BodyBytes []byte
                ....
                AuthInfoBytes []byte
                ....
                Signatures [][]byte
            end note
        return
        ProtoCodec -> codectypes : types.UnpackInterfaces(ptr, pc.interfaceRegistry)
            note over codectypes
                å› ä¸ºæ²¡æœ‰ TxRaw ç›¸å…³çš„æ³¨å†Œæ•°æ®ç»“æ„ï¼Œ
                æ‰€ä»¥è¿™é‡Œä»€ä¹ˆéƒ½æ²¡æœ‰åš
            end note 
        return 
    return

    note over txDecoder
        var body tx.TxBody
    end note

    txDecoder -> unknownproto : unknownproto.RejectUnknownFields(raw.BodyBytes, &body)
    return

    txDecoder -> ProtoCodec : cdc.Unmarshal(raw.BodyBytes, &body)
        ProtoCodec -> TxBody : TxBody.Unmarshal(raw.BodyBytes)
            note over TxBody
                è§£ç åï¼ŒTxBody çš„å„å­—æ®µè¢«å¡«å……ï¼Œ
            end note
        return
        ProtoCodec -> codectypes : types.UnpackInterfaces(body, ProtoCodec.interfaceRegistry)
            note over codectypes
                å°† body å¼ºè½¬ä¸º UnpackInterfacesMessage æ¥å£
            end note
            codectypes -> TxBody : msg.UnpackInterfaces(unpacker)
                note over TxBody
                    msg æ˜¯å¼ºè½¬ç±»å‹åçš„å˜é‡åï¼›
                    unpacker æ˜¯ codec.ProtoCodec.interfaceRegistry
                end note 
                TxBody -> typesTx :UnpackInterfaces(unpacker, m.Messages) //må°±æ˜¯TxBody
                    loop "m.Messagesæ˜¯ä¸ªæ•°ç»„ï¼Œéå†æ¯ä¸ªå…ƒç´ "
                        note over typesTx
                            var msg sdk.Msg
                        end note
                        typesTx -> interfaceRegistry : unpacker.UnpackAny(any, &msg)
                            note over interfaceRegistry
                                rt ä»£è¡¨ msg çš„ç±»å‹
                                imap := registry.interfaceImpls[rt] // æ‰¾åˆ°æ¥å£ç±»å‹çš„å®ç°æ˜ å°„
                                typ := imap[any.TypeUrl] //æ ¹æ®TypeURLæŸ¥æ‰¾å®ç°ç±»å‹ï¼›
                                // TypeUrl ä½œä¸ºå­—ç¬¦ä¸²ç¼–ç åœ¨äº† æ¶ˆæ¯ä¸­ï¼Œè¿›è¡Œåˆæ­¥ç•Œé¢æ—¶å³å¯è·å¾—
                                msg = reflect.New(typ.Elem()).Interface().(proto.Message) // ä½¿ç”¨åå°„æ„é€ æ¶ˆæ¯
                                proto.Unmarshal(any.Value, msg) // ä½¿ç”¨ proto è§£ç æ¶ˆæ¯
                            end note
                            interfaceRegistry -> typesTx : <color:red><size:18>é€’å½’è°ƒç”¨ UnpackInterfaces(msg, registry)</size></color>
                            return
                        return
                    end loop 
                return
            return
        return
    return

    note over txDecoder
        var authInfo tx.AuthInfo
    end note

    txDecoder -> unknownproto : unknownproto.RejectUnknownFieldsStrict(raw.AuthInfoBytes, &authInfo)
    return

    txDecoder -> ProtoCodec : cdc.Unmarshal(raw.AuthInfoBytes, &authInfo)
        ProtoCodec -> AuthInfo : AuthInfo.Unmarshal(raw.AuthInfoBytes)
            note over AuthInfo
                è§£ç åï¼ŒAuthInfo çš„å„å­—æ®µè¢«å¡«å……ï¼Œ
            end note
        return

        ProtoCodec -> codectypes : types.UnpackInterfaces(authInfo, ProtoCodec.interfaceRegistry)
            note over codectypes
                å¦‚æœæœ‰ç‹¬ç«‹çš„ SignerInfo æ•°æ®ï¼Œ
                types.UnpackInterfaces() ä¼šé€’å½’è§£ç  SignerInfo å­—æ®µï¼Œ
                è§£ç è¿‡ç¨‹ä¸­ï¼Œä¼šè°ƒç”¨åˆ°å„ä¸ªä¸šåŠ¡æ¨¡å—çš„è§£ç é€»è¾‘ã€‚
                <color:red>ä½†æ˜¯ï¼Œevmæ¨¡å—ä¸­ï¼Œæ•°æ®æ˜¯å’Œç­¾åæ··åˆåœ¨ä¸€èµ·çš„ï¼Œæ‰€ä»¥ä¸ä¼šç”¨åˆ°è¿™ä¸ªé€»è¾‘</color>
            end note
        return       
    return

    note over txDecoder
        ç»„è£…æ•°æ®ï¼Œè¿”å›
    end note
@enduml

@startuml 9.BaseApp.runMsgçš„è¯¦ç»†æµç¨‹
    title 
        BaseApp.runMsgçš„è¯¦ç»†æµç¨‹
    end title

    box cosmos
        participant BaseApp as "ğŸš§<<struct>> baseapp.BaseApp"
        participant EventManager as "ğŸš§<<struct>> types.EventManager"
        participant lambda_1 as "ğŸŒ€<<func>> \n baseapp.MsgServiceRouter.RegisterService \n è¿”å›çš„é—­åŒ…å‡½æ•°\n é—­åŒ…å‡½æ•°1"
        participant lambda_2 as "ğŸŒ€<<func>> \n é—­åŒ…å‡½æ•°1ä¸­å®šä¹‰çš„ interceptor é—­åŒ…å‡½æ•°\n é—­åŒ…å‡½æ•°2"
    end box 

    box ethermint
        participant pb_func as "ğŸŒ€<<func>> \n pbè‡ªåŠ¨ç”Ÿæˆçš„å¤„ç†å‡½æ•° \n x.evm._Msg_EthereumTx_Handler"
        participant lambda_3 as "ğŸŒ€<<func>> \n x.evm._Msg_EthereumTx_Handlerä¸­ç”Ÿæˆçš„handleré—­åŒ…å‡½æ•°"
        participant evmkeeper as "ğŸš§<<struct>> x.evm.keeper.Keeper"
    end box


    autonumber
    autoactivate on

    -> BaseApp : BaseApp.runMsgs(runMsgCtx, msgs, mode)
        note over BaseApp
            runMsgCtx æ˜¯ä¸€ä¸ªç»“æ„ä½“ï¼ŒåŒ…å«äº†ä¸€äº›ä¸Šä¸‹æ–‡ä¿¡æ¯ï¼Œåœ¨è¿›å…¥æœ¬å‡½æ•°å‰ï¼ŒrunMsgCtxå·²ç»
            æ˜¯ä¸€ä¸ªå’Œ mode æœ‰å…³çš„ç»“æ„äº†ï¼›
            ----
            msgs æ˜¯ []sdk.Msg ç±»å‹çš„æ•°ç»„
            ----
            mode æ˜¯ runTxMode ç±»å‹çš„å˜é‡ï¼Œè¡¨ç¤ºæ‰§è¡Œæ¨¡å¼ï¼Œmodeå–å€¼æœ‰ï¼š
            * runTxModeCheck // æ ¡éªŒ
            * runTxModeReCheck // åœ¨commitåï¼Œå¯¹pendingçš„äº‹åŠ¡å†æ ¡éªŒ
            * runTxModeSimulate // æ¨¡æ‹Ÿæ‰§è¡Œ <color:red>[ç³»ç»Ÿæœªä½¿ç”¨è¿™ç§æ¨¡å¼]</color>
            * runTxModeDeliver // è½åœ°å­˜å‚¨å¹¶æ‰§è¡Œäº‹åŠ¡
        end note

        loop å¯¹æ¯ä¸ªmsgè¿›è¡Œå¤„ç†
            alt åªå¤„ç† mode ä¸º runTxModeSimulate runTxModeDeliver çš„åœºæ™¯
                note over BaseApp
                    ä»BaseApp.moduleRouter.msgServiceRouter ä¸­ï¼Œæ ¹æ®msgçš„TypeUrl
                    æ‰¾åˆ°å¯¹åº”çš„ MsgServiceHandler 
                end note 
                note over BaseApp #LimeGreen
                BaseApp.moduleRouter.msgServiceRouter çš„åˆå§‹åŒ–ï¼š
                ====
                <code>
                // RegisterServices registers all module services
                // è¿™ä¸ª Manager å°±æ˜¯ EthermintApp ä¸­çš„ ModuleManager
                func (m *Manager) RegisterServices(cfg Configurator) {
                    for _, module := range m.Modules {
                        // RegisterServices(cfg) æ˜¯
                        module.RegisterServices(cfg)
                    }
                }
                </code>
                end note 
                BaseApp -> lambda_1 :
                    note over lambda_1
                        é—­åŒ…å‡½æ•°çš„å‚æ•°æ˜¯ ctx sdk.Context, msg sdk.Msg
                        é—­åŒ…å‡½æ•°çš„è¿”å›å€¼æ˜¯ sdk.Result
                        ----
                        MsgServiceHandler æ˜¯ baseapp.RegisterServiceè¿”å›çš„ä¸€ä¸ªé—­åŒ…å‡½æ•°ï¼Œ
                        åœ¨è¿™ä¸ªé—­åŒ…å‡½æ•°ä¸­ï¼Œä¼šè°ƒç”¨åˆ°ä¸šåŠ¡æ¨¡å—çš„å¤„ç†é€»è¾‘;
                    end note

                    
                    lambda_1 -> pb_func : å‚æ•°ä¸­åŒ…å«ä¸€ä¸ª interceptor å‡½æ•°æŒ‡é’ˆ
                        note over pb_func 
                            æ„é€ ä¸€ä¸ªé—­åŒ…å‡½æ•°, handler
                        end note 

                        pb_func -> lambda_2 : å‚æ•°ä¸­åŒ…å«åˆšæ‰æ„é€ çš„handler
                            lambda_2 -> lambda_3 : 
                            note over lambda_3
                                å‚æ•°æ˜¯ : ctx context.Context, req interface{}
                                req å¯ä»¥è¢«å¼ºè½¬ä¸º MsgEthereumTx ç±»å‹
                                ....
                                å› ä¸ºåœ¨æ¶ˆæ¯è§£ç æ—¶å·²å®Œæˆäº†å®é™…çš„ç±»å‹è½¬æ¢
                            end note 

                            lambda_3 -> evmkeeper : Keeper.EthereumTx
                                evmkeeper -> evmkeeper : Keeper.ApplyTransaction(ctx, msg)
                                    '
                                return: MsgEthereumTxResponse response 

                                note over evmkeeper
                                    äº‹åŠ¡æœ¬èº«çš„ä¿¡æ¯(ehterumTxHashç­‰)
                                    äº‹åŠ¡æ‰§è¡Œåæ‰€å¾—çš„Log(åˆçº¦ä¸­æŠ›å‡ºçš„event)
                                    ä¸€å¹¶è¢«å°è£…åˆ°ä¸€ä¸ª abci.Event æ•°ç»„ä¸­ã€‚
                                end note

                                evmkeeper -> EventManager : EmitEvents.EmitEvents(events)
                                    note over EventManager
                                        EventManager æ˜¯ contex ä¸­çš„ä¸€ä¸ªå­—æ®µ
                                        ----
                                        EmitEventså‡½æ•°å®ç°ï¼š
                                        <code>
                                            // åªæ˜¯è®°å½•events
                                            em.events = em.events.AppendEvents(events)
                                        </code>
                                    end note
                                return
                            return

                            return : interface{} //å®é™…ä¸Šæ˜¯ MsgEthereumTxResponse

                        return : interface{} //å®é™…ä¸Šæ˜¯ MsgEthereumTxResponse
                    return 


                    note over lambda_1 
                        åœ¨é—­åŒ…å‡½æ•°ä¸­ï¼Œè°ƒç”¨ WrapServiceResult æ„é€ æ‰§è¡Œç»“æœ
                        sdk.Result ç»“æ„ä½“
                        Dataï¼š MsgEthereumTxResponseå¯¹è±¡è¿›è¡Œprotoç¼–ç ï¼›
                        Eventsï¼š ä»contex.EventManagerä¸­å–å‡ºevents
                        MsgResponses: MsgEthereumTxResponse è½¬ä¸º any æ¥å£
                    end note 

                return msgEvents = sdk.Result

            note over BaseApp
                <code>
                msgEvents := sdk.Events{
                    // sdk.EventTypeMessage = "message"
                    // sdk.AttributeKeyAction = "action"
                    // eventMsgName = "/ethermint.evm.v1.MsgEthereumTx"
                    sdk.NewEvent(sdk.EventTypeMessage, sdk.NewAttribute(sdk.AttributeKeyAction, eventMsgName)),
                }
                msgEvents = msgEvents.AppendEvents(msgResult.GetEvents())
                events = events.AppendEvents(msgEvents) // æ”¶é›†æ‰€æœ‰æ¶ˆæ¯æ‰§è¡Œçš„ event
                </code>
                ----
                <code>
                msgResponse := msgResult.MsgResponses[0] // å°±æ˜¯ MsgEthereumTxResponse
                msgResponses = append(msgResponses, msgResponse) // æ”¶é›†æ‰€æœ‰æ¶ˆæ¯æ‰§è¡Œç»“æœ
                </code>
                ----
                <code>
                msgLogs = append(msgLogs, sdk.NewABCIMessageLog(uint32(i), msgResult.Log, msgEvents))
                // å°±æ˜¯å¯¹ msgEvents è¿›è¡Œäº†ä¸€ä¸‹å°è£…ï¼Œ å°† msgEvents è½¬æˆäº†å­—ç¬¦ä¸²
                </code>
                ----
                <code>
                data = makeABCIData(msgResponses)
                </code>
            end note 
            end 
        end
        note over BaseApp 
            <code>
                return &sdk.Result{
                    Data:         data,
                    Log:          strings.TrimSpace(msgLogs.String()),
                    Events:       events.ToABCIEvents(),
                    MsgResponses: msgResponses,
                }
            </code>
        end note 
    return sdk.Result

@enduml

